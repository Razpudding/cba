import SimpleSchema from 'simpl-schema';
import { sample, extend, entries, get, intersection, isMatch, isEqual, setWith, set, unset, includes, pickBy } from 'lodash';
import { t } from 'ttag';
import * as Qty from 'js-quantities';
import { Error as Error$1 } from 'js-quantities';

const FormatVersion = '4.7.2';

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

SimpleSchema.extendOptions(['accessibility']);
/**
 * Context for the question function, to read additional fields or generate questions dynamically
 */

class QuestionFunctionContext {}
function makeQuestionContext(path, value, schema) {
  return new QuestionFunctionContext();
}
function evaluateQuestionValue(question, context) {
  if (typeof question === 'string') {
    return question;
  }

  if (Array.isArray(question)) {
    return sample(question);
  }

  if (typeof question === 'function') {
    return question(context);
  }

  return undefined;
}
function evaluateAccessibilitySchemaExtension(extension, context) {
  let question = extension.question,
      questionMore = extension.questionMore,
      questionBlockBegin = extension.questionBlockBegin,
      remaining = __rest(extension, ["question", "questionMore", "questionBlockBegin"]);

  if (question) {
    question = evaluateQuestionValue(question, context);
  }

  if (questionMore) {
    questionMore = evaluateQuestionValue(questionMore, context);
  }

  if (questionBlockBegin) {
    questionBlockBegin = evaluateQuestionValue(questionBlockBegin, context);
  }

  return Object.assign({
    question,
    questionMore,
    questionBlockBegin
  }, remaining);
}
/**
 * Internal helper for creating schemata with attached schemaType
 */

function createSchemaInstance(type, definition) {
  let baseSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  let schemaOptions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const extendedSchema = new SimpleSchema(definition, schemaOptions);

  if (baseSchema) {
    extendedSchema.extend(baseSchema);
  }

  extendedSchema.__schemaType = type;
  extendedSchema.__schemaVersion = FormatVersion;
  return extendedSchema;
}
/**
 * A schema for validating the AccessibilitySchemaExtension. Used for internal tests.
 */

const AccessibilitySchemaExtensionSchema = new SimpleSchema({
  example: {
    type: String,
    optional: true
  },
  description: {
    type: String,
    optional: true
  },
  extendedInformationUrl: {
    type: String,
    optional: true
  },
  options: {
    type: Array,
    optional: true
  },
  'options.$': {
    type: Object,
    blackbox: true
  },
  // FIXME disabled value validation until SimpleSchema.oneOf bug is fixed
  // https://github.com/aldeed/simple-schema-js/issues/112
  // 'options.$.value': {
  //   type: SimpleSchema.oneOf(
  //     String,
  //     {
  //       type: Object,
  //       blackbox: true
  //     },
  //     Number,
  //   ),
  // },
  'options.$.label': {
    type: String
  },
  question: {
    type: String,
    optional: true
  },
  questionMore: {
    type: String,
    optional: true
  },
  questionBlockBegin: {
    type: String,
    optional: true
  },
  machineData: {
    type: Boolean,
    optional: true
  },
  componentHint: {
    type: String,
    optional: true
  },
  inseparable: {
    type: Boolean,
    optional: true
  },
  preferredUnit: {
    type: String,
    optional: true
  },
  deprecated: {
    type: Boolean,
    optional: true
  }
});

const PersonalProfileSchema = new SimpleSchema({
  muteness: {
    type: Boolean,
    optional: true
  },
  guideDog: {
    type: Boolean,
    optional: true
  },
  hearingImpairment: {
    type: Boolean,
    optional: true
  },
  learningImpairment: {
    type: Boolean,
    optional: true
  },
  mobilityImpairment: {
    type: Boolean,
    optional: true
  },
  visualImpairment: {
    type: Boolean,
    optional: true
  },
  blindness: {
    type: Boolean,
    optional: true
  },
  wheelchair: {
    type: Boolean,
    optional: true
  }
});

SimpleSchema.setDefaultMessages({
  messages: {
    en: {
      invalid_unit: 'Invalid Unit'
    }
  }
});
/**
 * The unit kind for length units such as meter, centimeter or inch
 */

const LengthUnitKind = 'length';
const OtherUnitKind = 'other';
/**
 * Builds a custom validation function that ensures that the value of the field
 * is a unit of the kind passed to `validateUnit`
 *
 * If the validation fails, a new `invalid_unit` error message is raised.
 *
 * @param {string} kind One of js-quantities unit kinds, e.g. length, mass, etc.
 * @returns {ValidationFunction} A custom SimpleSchema Validation function
 */

const validateUnit = function (kind) {
  return function () {
    try {
      const qty = new Qty(this.value);

      if (!qty || qty.scalar !== 1 || qty.kind() !== kind) {
        return 'invalid_unit';
      }
    } catch (e) {
      if (e instanceof Error$1) {
        return 'invalid_unit';
      } else {
        throw e;
      }
    }

    return undefined;
  };
};
/**
 * The BaseQuantitySchema allows easy validation, cleaning and checking of quantity objects.
 * It does not define a unit kind, and will not validate the unit.
 */

const BaseQuantitySchema = new SimpleSchema({
  operator: {
    type: String,
    allowedValues: ['<', '<=', '==', '>=', '>'],
    optional: true
  },
  value: {
    type: Number
  },
  unit: {
    type: String
  },
  accuracy: {
    type: Number,
    optional: true
  },
  rawValue: {
    type: String,
    optional: true
  }
}); // takes the BaseQuantitySchema and extends it with validation for the given unit type

const makeQuantitySchema = (kind, defaultValue) => {
  return createSchemaInstance('Quantity', {
    unit: {
      type: String,
      custom: validateUnit(kind),
      defaultValue,
      accessibility: {
        preferredUnit: kind
      }
    }
  }, BaseQuantitySchema);
};
/**
 * Looks at a simple schema, and determines the unit used for a key.
 * If the SimpleSchema is a QuantitySchema will always look at the unit key.
 *
 * @param {SimpleSchema} schema the schema to determine the unit of
 * @param {string} key the key to the schema property to determine the unit of
 * @returns {string} 'unknown' or one of the js-quantities unit kinds (e.g. 'length')
 */


const determineUnitKind = (schema, key) => {
  if (!SimpleSchema.isSimpleSchema(schema)) {
    throw new Error('No simple schema passed to determineUnitKind');
  }

  if (schema.__schemaType === 'Quantity') {
    key = 'unit';
  } else {
    if (!key) {
      throw new Error('No key passed into determineUnitKind for non Quantity schema');
    }

    key = `${key}.unit`;
  }

  const definition = schema.getDefinition(key, ['accessibility']);

  if (!definition || !definition.accessibility || !definition.accessibility.preferredUnit) {
    return 'unknown';
  }

  return definition.accessibility.preferredUnit;
};
/**
 * The LengthQuantitySchema allows easy validation, cleaning and checking of length quantity objects.
 * It validates the unit and will only accept length units, eg. meter, centimeter or inch.
 */

const LengthQuantitySchema = makeQuantitySchema(LengthUnitKind, 'meter');
const VolumeQuantitySchema = makeQuantitySchema(OtherUnitKind, 'decibel');
const LengthSchema = SimpleSchema.oneOf(LengthQuantitySchema, String);
const VolumeSchema = SimpleSchema.oneOf(VolumeQuantitySchema, String);
function quantityDefinition(type) {
  let optional = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  let accessibility = arguments.length > 2 ? arguments[2] : undefined;
  const base = {
    type: LengthSchema,
    accessibility: {
      inseparable: true,
      componentHint: 'Unit'
    }
  };

  if (optional === true) {
    base.optional = optional;
  }

  if (accessibility) {
    extend(base.accessibility, accessibility);
  }

  return base;
}

const DoorSchema = new SimpleSchema({
  turningSpaceInFront: quantityDefinition(LengthSchema, true, {
    question: t`How much space for turning is there at the entrance?`
  }),
  doorOpensToOutside: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the door open to the outside?`
    }
  },
  isAutomaticOrAlwaysOpen: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this an automatic door or is the door always open?`
    }
  },
  width: quantityDefinition(LengthSchema, true, {
    question: t`How wide is the door?`,
    description: t`This refers to the maximum size of an object that can pass.`
  }),
  hasClearMarkingOnGlassDoor: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the glass door have clear markings?`
    }
  },
  isEasyToHoldOpen: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this an automatic door or is the door always open?`
    }
  },
  hasErgonomicDoorHandle: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does this door have an ergonomic handle?`
    }
  },
  isRevolving: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this a revolving door?`
    }
  },
  needsRadarKey: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does this door require a radar key?`
    }
  },
  needsEuroKey: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does this door require an euro key?`
    }
  }
});

/**
 * Localized strings can either be just `String`s, or be `Object`s with IETF language tags
 * as property names and localized strings as property values.
 */
const LocalizedStringSchema = {
  type: Object,
  blackbox: true,
  optional: true
};

const StairsSchema = createSchemaInstance('Stairs', {
  /// number of steps
  count: {
    type: Number,
    optional: true,
    accessibility: {
      question: t`How many steps are there?`
    }
  },
  nosing: {
    type: Object,
    optional: true,
    accessibility: {}
  },
  'nosing.isHighContrast': {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Are the steps nosings marked for higher contrast?`
    }
  },
  'nosing.isAntiSlip': {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Do the steps have anti-slip material?`
    }
  },
  name: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`What is the name of these stairs?`
    }
  },
  stepHeight: quantityDefinition(LengthSchema, true, {
    question: t`How high is this step / are these steps?`
  }),
  hasHandRail: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a hand rail?`
    }
  },
  hasTactileSafetyStrips: {
    type: Boolean,
    optional: true,
    accessibility: {
      description: t`Do the stairs have tactile safety strips?`
    }
  },
  hasBrailleNavigation: {
    type: Boolean,
    optional: true,
    accessibility: {
      description: t`Do the stairs have braille navigation hints printed on the rails?`
    }
  },
  alternativeMobileEquipmentIds: {
    type: Array,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`accessibility.cloud IDs of alternative escalators, elevators, hoists, or stair lifts to replace this pathway`
    }
  },
  'alternativeMobileEquipmentIds.$': {
    type: String,
    label: t`accessibility.cloud Equipment ID`
  }
});

const EntranceSchema = new SimpleSchema({
  name: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`What is the name of this entrance?`,
      example: t`e.g. main entrance`
    }
  },
  isMainEntrance: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this the main entrance?`
    }
  },
  isLevel: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the entrance stepless?`
    }
  },
  slopeAngle: {
    type: Number,
    optional: true,
    accessibility: {
      description: t`Grade in percent as calculated by \`100 * rise / run\` or the tangent of the angle of inclination times 100`,
      question: t`What is the angle of the slope?`
    }
  },
  hasFixedRamp: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a fixed ramp to enter the place?`
    }
  },
  hasRemovableRamp: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is a portable ramp available? Please check with the staff on-site.`
    }
  },
  stairs: {
    type: StairsSchema,
    optional: true,
    label: t`Stairs`,
    accessibility: {
      question: t`Are there steps at the entrance?`
    }
  },
  door: {
    type: DoorSchema,
    optional: true,
    label: t`Door`,
    accessibility: {
      questionBlockBegin: t`Would you like to add information about the door at the entrance?`
    }
  },
  elevatorEquipmentId: {
    type: String,
    optional: true,
    accessibility: {
      question: t`Is there a lift at this entrance?`,
      machineData: true // TODO foreign object flow equipment

    }
  },
  intercomEquipmentId: {
    type: String,
    optional: true,
    accessibility: {
      question: t`Is there an intercom at this entrance?`,
      machineData: true // TODO foreign object flow equipment

    }
  }
});

const RoomSchema = createSchemaInstance('Room', {
  isAccessibleWithWheelchair: {
    type: Boolean,
    optional: true,
    accessibility: {
      machineData: true
    }
  }
});

const MirrorSchema = createSchemaInstance('Mirror', {
  isLocatedInsideRestroom: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the mirror inside the restroom?`
    }
  },
  isAccessibleWhileSeated: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Can the mirror be used when sitting in a wheelchair?`
    }
  },
  heightFromGround: quantityDefinition(LengthSchema)
});

const WashBasinSchema = createSchemaInstance('WashBasin', {
  isLocatedInsideRestroom: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the wash basin located inside the restroom cabin?`
    }
  },
  height: quantityDefinition(LengthSchema, true, {
    question: t`At which height is the wash basin's top?`
  }),
  accessibleWithWheelchair: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Can a wheelchair drive under the wash basin?`
    }
  },
  spaceBelow: {
    type: Object,
    optional: true,
    accessibility: {
      question: t`Let’s take a look at the space below the wash basin.`
    }
  },
  spaceBelowHeight: quantityDefinition(LengthSchema, true, {
    question: t`How high is the space below the wash basin?`
  }),
  spaceBelowDepth: quantityDefinition(LengthSchema, true, {
    question: t`How deep is the space below the wash basin?`
  })
});

const GrabBarsSchema = createSchemaInstance('GrabBars', {
  onUsersLeftSide: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a folding handle on left side? (from the perspective of somebody using the toilet)`
    }
  },
  onUsersRightSide: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a folding handle on right side? (from the perspective of somebody using the toilet)`
    }
  },
  topHeightFromFloor: quantityDefinition(LengthSchema, true, {
    question: t`How high are the grab bars (top edge, measured from the floor)`
  }),
  distanceBetweenBars: quantityDefinition(LengthSchema, true, {
    question: t`How far are the bars apart?`
  }),
  foldable: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Can the grab bars be folded? If only one can be folded, answer 'No'.`
    }
  }
});

const ToiletSchema = createSchemaInstance('Toilet', {
  heightOfBase: quantityDefinition(LengthSchema, true, {
    question: t`How high is the toilet’s base?`
  }),
  spaceOnUsersLeftSide: quantityDefinition(LengthSchema, true, {
    question: t`How much space is on the left side of the toilet? (from the perspective of somebody using the toilet)`
  }),
  spaceOnUsersRightSide: quantityDefinition(LengthSchema, true, {
    question: t`How much space is on the right side of the toilet? (from the perspective of somebody using the toilet)`
  }),
  spaceInFront: quantityDefinition(LengthSchema, true, {
    question: t`How much space is in front of the toilet?`
  }),
  hasGrabBars: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the toilet have grab bars?`
    }
  },
  grabBars: {
    type: GrabBarsSchema,
    optional: true,
    accessibility: {
      question: t`Let’s describe the grab bars.`
    }
  }
});

const ShowerSchema = createSchemaInstance('Shower', {
  step: quantityDefinition(LengthSchema),
  isLevel: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the shower step-free and level with the space in front of it?`
    }
  },
  hasSupportRails: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the shower have support rails?`
    }
  },
  supportRails: {
    type: Object,
    optional: true,
    accessibility: {
      question: t`Let’s describe the support rails further.`
    }
  },
  supportRailsHeight: quantityDefinition(LengthSchema, true, {
    question: t`At which height are the support rails?`
  }),
  supportRailsAreAboveAndBelowControls: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Are the support rails above and below the controls?`
    }
  },
  hasShowerSeat: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a shower seat?`
    }
  },
  hasErgonomicHandle: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there an ergonomic handle?`
    }
  },
  showerSeatIsRemovable: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the seat removable from the shower?`
    }
  },
  showerSeatIsFolding: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this a folding seat?`
    }
  }
});

const restroomSignIcons = ['allGender', 'female', 'male', 'personInWheelchair', 'changingTable', 'baby', 'family', 'urinal', 'washBasin', 'toiletBowl'];
const RestroomSchema = createSchemaInstance('Restroom', {
  signIcons: {
    type: Array,
    optional: true,
    accessibility: {
      description: t`Visible icons on the restroom’s sign`
    }
  },
  'signIcons.$': {
    type: String,
    allowedValues: restroomSignIcons
  },
  hasMirror: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the restroom have a mirror?`
    }
  },
  mirror: {
    type: MirrorSchema,
    optional: true,
    accessibility: {}
  },
  turningSpaceInside: quantityDefinition(LengthSchema, true, {
    question: t`How wide is the space inside that is usable for turning?`
  }),
  hasSupportRails: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Are there support rails on the walls?`
    }
  },
  toilet: {
    type: ToiletSchema,
    label: t`Toilet`,
    optional: true,
    accessibility: {
      question: t`Let’s take a look at the toilet.`
    }
  },
  hasBathTub: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there a bath tub in this room?`
    }
  },
  entrance: {
    type: EntranceSchema,
    label: t`Entrance`,
    optional: true,
    accessibility: {
      question: t`Would you like to add information about the entrance to the restroom?`
    }
  },
  hasShower: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does the restroom have a shower?`
    }
  },
  shower: {
    type: ShowerSchema,
    optional: true,
    accessibility: {
      question: t`Would you like to add information about the shower?`
    }
  },
  heightOfSoap: quantityDefinition(LengthSchema, true, {
    question: t`At which height from the floor is the soap?`
  }),
  heightOfDrier: quantityDefinition(LengthSchema, true, {
    question: t`At which height from the floor is the drier or towel?`
  }),
  washBasin: {
    type: WashBasinSchema,
    optional: true,
    accessibility: {
      question: t`Would you like to add information about the wash basin?`
    }
  }
}, RoomSchema);

/**
 * All existing IETF language tags.
 */
const ietfLanguageTags = ['af', 'af-NA', 'af-ZA', 'agq', 'agq-CM', 'ak', 'ak-GH', 'am', 'am-ET', 'ar', 'ar-001', 'ar-AE', 'ar-BH', 'ar-DJ', 'ar-DZ', 'ar-EG', 'ar-EH', 'ar-ER', 'ar-IL', 'ar-IQ', 'ar-JO', 'ar-KM', 'ar-KW', 'ar-LB', 'ar-LY', 'ar-MA', 'ar-MR', 'ar-OM', 'ar-PS', 'ar-QA', 'ar-SA', 'ar-SD', 'ar-SO', 'ar-SS', 'ar-SY', 'ar-TD', 'ar-TN', 'ar-YE', 'as', 'as-IN', 'asa', 'asa-TZ', 'ast', 'ast-ES', 'az', 'az-Cyrl', 'az-Cyrl-AZ', 'az-Latn', 'az-Latn-AZ', 'bas', 'bas-CM', 'be', 'be-BY', 'bem', 'bem-ZM', 'bez', 'bez-TZ', 'bg', 'bg-BG', 'bm', 'bm-ML', 'bn', 'bn-BD', 'bn-IN', 'bo', 'bo-CN', 'bo-IN', 'br', 'br-FR', 'brx', 'brx-IN', 'bs', 'bs-Cyrl', 'bs-Cyrl-BA', 'bs-Latn', 'bs-Latn-BA', 'ca', 'ca-AD', 'ca-ES', 'ca-ES-VALENCIA', 'ca-FR', 'ca-IT', 'ccp', 'ccp-BD', 'ccp-IN', 'ce', 'ce-RU', 'cgg', 'cgg-UG', 'chr', 'chr-US', 'ckb', 'ckb-IQ', 'ckb-IR', 'cs', 'cs-CZ', 'cu', 'cu-RU', 'cy', 'cy-GB', 'da', 'da-DK', 'da-GL', 'dav', 'dav-KE', 'de', 'de-AT', 'de-BE', 'de-CH', 'de-DE', 'de-IT', 'de-LI', 'de-LU', 'dje', 'dje-NE', 'dsb', 'dsb-DE', 'dua', 'dua-CM', 'dyo', 'dyo-SN', 'dz', 'dz-BT', 'ebu', 'ebu-KE', 'ee', 'ee-GH', 'ee-TG', 'el', 'el-CY', 'el-GR', 'en', 'en-001', 'en-150', 'en-AG', 'en-AI', 'en-AS', 'en-AT', 'en-AU', 'en-BB', 'en-BE', 'en-BI', 'en-BM', 'en-BS', 'en-BW', 'en-BZ', 'en-CA', 'en-CC', 'en-CH', 'en-CK', 'en-CM', 'en-CX', 'en-CY', 'en-DE', 'en-DG', 'en-DK', 'en-DM', 'en-ER', 'en-FI', 'en-FJ', 'en-FK', 'en-FM', 'en-GB', 'en-GD', 'en-GG', 'en-GH', 'en-GI', 'en-GM', 'en-GU', 'en-GY', 'en-HK', 'en-IE', 'en-IL', 'en-IM', 'en-IN', 'en-IO', 'en-JE', 'en-JM', 'en-KE', 'en-KI', 'en-KN', 'en-KY', 'en-LC', 'en-LR', 'en-LS', 'en-MG', 'en-MH', 'en-MO', 'en-MP', 'en-MS', 'en-MT', 'en-MU', 'en-MW', 'en-MY', 'en-NA', 'en-NF', 'en-NG', 'en-NL', 'en-NR', 'en-NU', 'en-NZ', 'en-PG', 'en-PH', 'en-PK', 'en-PN', 'en-PR', 'en-PW', 'en-RW', 'en-SB', 'en-SC', 'en-SD', 'en-SE', 'en-SG', 'en-SH', 'en-SI', 'en-SL', 'en-SS', 'en-SX', 'en-SZ', 'en-TC', 'en-TK', 'en-TO', 'en-TT', 'en-TV', 'en-TZ', 'en-UG', 'en-UM', 'en-US', 'en-US-POSIX', 'en-VC', 'en-VG', 'en-VI', 'en-VU', 'en-WS', 'en-ZA', 'en-ZM', 'en-ZW', 'eo', 'eo-001', 'es', 'es-419', 'es-AR', 'es-BO', 'es-BR', 'es-BZ', 'es-CL', 'es-CO', 'es-CR', 'es-CU', 'es-DO', 'es-EA', 'es-EC', 'es-ES', 'es-GQ', 'es-GT', 'es-HN', 'es-IC', 'es-MX', 'es-NI', 'es-PA', 'es-PE', 'es-PH', 'es-PR', 'es-PY', 'es-SV', 'es-US', 'es-UY', 'es-VE', 'et', 'et-EE', 'eu', 'eu-ES', 'ewo', 'ewo-CM', 'fa', 'fa-AF', 'fa-IR', 'ff', 'ff-Latn', 'ff-Latn-BF', 'ff-Latn-CM', 'ff-Latn-GH', 'ff-Latn-GM', 'ff-Latn-GN', 'ff-Latn-GW', 'ff-Latn-LR', 'ff-Latn-MR', 'ff-Latn-NE', 'ff-Latn-NG', 'ff-Latn-SL', 'ff-Latn-SN', 'fi', 'fi-FI', 'fil', 'fil-PH', 'fo', 'fo-DK', 'fo-FO', 'fr', 'fr-BE', 'fr-BF', 'fr-BI', 'fr-BJ', 'fr-BL', 'fr-CA', 'fr-CD', 'fr-CF', 'fr-CG', 'fr-CH', 'fr-CI', 'fr-CM', 'fr-DJ', 'fr-DZ', 'fr-FR', 'fr-GA', 'fr-GF', 'fr-GN', 'fr-GP', 'fr-GQ', 'fr-HT', 'fr-KM', 'fr-LU', 'fr-MA', 'fr-MC', 'fr-MF', 'fr-MG', 'fr-ML', 'fr-MQ', 'fr-MR', 'fr-MU', 'fr-NC', 'fr-NE', 'fr-PF', 'fr-PM', 'fr-RE', 'fr-RW', 'fr-SC', 'fr-SN', 'fr-SY', 'fr-TD', 'fr-TG', 'fr-TN', 'fr-VU', 'fr-WF', 'fr-YT', 'fur', 'fur-IT', 'fy', 'fy-NL', 'ga', 'ga-IE', 'gd', 'gd-GB', 'gl', 'gl-ES', 'gsw', 'gsw-CH', 'gsw-FR', 'gsw-LI', 'gu', 'gu-IN', 'guz', 'guz-KE', 'gv', 'gv-IM', 'ha', 'ha-GH', 'ha-NE', 'ha-NG', 'haw', 'haw-US', 'he', 'he-IL', 'hi', 'hi-IN', 'hr', 'hr-BA', 'hr-HR', 'hsb', 'hsb-DE', 'hu', 'hu-HU', 'hy', 'hy-AM', 'ia', 'ia-001', 'id', 'id-ID', 'ig', 'ig-NG', 'ii', 'ii-CN', 'is', 'is-IS', 'it', 'it-CH', 'it-IT', 'it-SM', 'it-VA', 'ja', 'ja-JP', 'jgo', 'jgo-CM', 'jmc', 'jmc-TZ', 'jv', 'jv-ID', 'ka', 'ka-GE', 'kab', 'kab-DZ', 'kam', 'kam-KE', 'kde', 'kde-TZ', 'kea', 'kea-CV', 'khq', 'khq-ML', 'ki', 'ki-KE', 'kk', 'kk-KZ', 'kkj', 'kkj-CM', 'kl', 'kl-GL', 'kln', 'kln-KE', 'km', 'km-KH', 'kn', 'kn-IN', 'ko', 'ko-KP', 'ko-KR', 'kok', 'kok-IN', 'ks', 'ks-IN', 'ksb', 'ksb-TZ', 'ksf', 'ksf-CM', 'ksh', 'ksh-DE', 'ku', 'ku-TR', 'kw', 'kw-GB', 'ky', 'ky-KG', 'lag', 'lag-TZ', 'lb', 'lb-LU', 'lg', 'lg-UG', 'lkt', 'lkt-US', 'ln', 'ln-AO', 'ln-CD', 'ln-CF', 'ln-CG', 'lo', 'lo-LA', 'lrc', 'lrc-IQ', 'lrc-IR', 'lt', 'lt-LT', 'lu', 'lu-CD', 'luo', 'luo-KE', 'luy', 'luy-KE', 'lv', 'lv-LV', 'mas', 'mas-KE', 'mas-TZ', 'mer', 'mer-KE', 'mfe', 'mfe-MU', 'mg', 'mg-MG', 'mgh', 'mgh-MZ', 'mgo', 'mgo-CM', 'mi', 'mi-NZ', 'mk', 'mk-MK', 'ml', 'ml-IN', 'mn', 'mn-MN', 'mr', 'mr-IN', 'ms', 'ms-BN', 'ms-MY', 'ms-SG', 'mt', 'mt-MT', 'mua', 'mua-CM', 'my', 'my-MM', 'mzn', 'mzn-IR', 'naq', 'naq-NA', 'nb', 'nb-NO', 'nb-SJ', 'nd', 'nd-ZW', 'nds', 'nds-DE', 'nds-NL', 'ne', 'ne-IN', 'ne-NP', 'nl', 'nl-AW', 'nl-BE', 'nl-BQ', 'nl-CW', 'nl-NL', 'nl-SR', 'nl-SX', 'nmg', 'nmg-CM', 'nn', 'nn-NO', 'nnh', 'nnh-CM', 'nus', 'nus-SS', 'nyn', 'nyn-UG', 'om', 'om-ET', 'om-KE', 'or', 'or-IN', 'os', 'os-GE', 'os-RU', 'pa', 'pa-Arab', 'pa-Arab-PK', 'pa-Guru', 'pa-Guru-IN', 'pl', 'pl-PL', 'prg', 'prg-001', 'ps', 'ps-AF', 'pt', 'pt-AO', 'pt-BR', 'pt-CH', 'pt-CV', 'pt-GQ', 'pt-GW', 'pt-LU', 'pt-MO', 'pt-MZ', 'pt-PT', 'pt-ST', 'pt-TL', 'qu', 'qu-BO', 'qu-EC', 'qu-PE', 'rm', 'rm-CH', 'rn', 'rn-BI', 'ro', 'ro-MD', 'ro-RO', 'rof', 'rof-TZ', 'root', 'ru', 'ru-BY', 'ru-KG', 'ru-KZ', 'ru-MD', 'ru-RU', 'ru-UA', 'rw', 'rw-RW', 'rwk', 'rwk-TZ', 'sah', 'sah-RU', 'saq', 'saq-KE', 'sbp', 'sbp-TZ', 'sd', 'sd-PK', 'se', 'se-FI', 'se-NO', 'se-SE', 'seh', 'seh-MZ', 'ses', 'ses-ML', 'sg', 'sg-CF', 'shi', 'shi-Latn', 'shi-Latn-MA', 'shi-Tfng', 'shi-Tfng-MA', 'si', 'si-LK', 'sk', 'sk-SK', 'sl', 'sl-SI', 'smn', 'smn-FI', 'sn', 'sn-ZW', 'so', 'so-DJ', 'so-ET', 'so-KE', 'so-SO', 'sq', 'sq-AL', 'sq-MK', 'sq-XK', 'sr', 'sr-Cyrl', 'sr-Cyrl-BA', 'sr-Cyrl-ME', 'sr-Cyrl-RS', 'sr-Cyrl-XK', 'sr-Latn', 'sr-Latn-BA', 'sr-Latn-ME', 'sr-Latn-RS', 'sr-Latn-XK', 'sv', 'sv-AX', 'sv-FI', 'sv-SE', 'sw', 'sw-CD', 'sw-KE', 'sw-TZ', 'sw-UG', 'ta', 'ta-IN', 'ta-LK', 'ta-MY', 'ta-SG', 'te', 'te-IN', 'teo', 'teo-KE', 'teo-UG', 'tg', 'tg-TJ', 'th', 'th-TH', 'ti', 'ti-ER', 'ti-ET', 'tk', 'tk-TM', 'to', 'to-TO', 'tr', 'tr-CY', 'tr-TR', 'tt', 'tt-RU', 'twq', 'twq-NE', 'tzm', 'tzm-MA', 'ug', 'ug-CN', 'uk', 'uk-UA', 'ur', 'ur-IN', 'ur-PK', 'uz', 'uz-Arab', 'uz-Arab-AF', 'uz-Cyrl', 'uz-Cyrl-UZ', 'uz-Latn', 'uz-Latn-UZ', 'vai', 'vai-Latn', 'vai-Latn-LR', 'vai-Vaii', 'vai-Vaii-LR', 'vi', 'vi-VN', 'vo', 'vo-001', 'vun', 'vun-TZ', 'wae', 'wae-CH', 'wo', 'wo-SN', 'xh', 'xh-ZA', 'xog', 'xog-UG', 'yav', 'yav-CM', 'yi', 'yi-001', 'yo', 'yo-BJ', 'yo-NG', 'yue', 'yue-Hans', 'yue-Hans-CN', 'yue-Hant', 'yue-Hant-HK', 'zgh', 'zgh-MA', 'zh', 'zh-Hans', 'zh-Hans-CN', 'zh-Hans-HK', 'zh-Hans-MO', 'zh-Hans-SG', 'zh-Hant', 'zh-Hant-HK', 'zh-Hant-MO', 'zh-Hant-TW', 'zu', 'zu-ZA'];
/**
 * We support IETF language tags for sign language (https://tools.ietf.org/html/rfc5646).
 *
 * For sign language translations of strings, you can use media URLs pointing to video, video
 * websites or description pictures. If there are several alternatives, it's best to point to a
 * video.
 */

const signLanguageCodes = ['ase', 'sgn-ase', 'sgn-ase-US', 'sgn-GH-EP', 'sgn-DZ', 'sgn-US', 'sgn-AR', 'sgn-AM', 'sgn-AU-NT', 'sgn-AU', 'sgn-AT', 'sgn-ID-BA', 'sgn-BE-VLG', 'sgn-BE-WAL', 'sgn-BO', 'sgn-BR', 'sgn-GB', 'sgn-BG', 'sgn-ES-CT', 'sgn-TD', 'sgn-CL', 'sgn-CN', 'sgn-CO', 'sgn-CR', 'sgn-CZ', 'sgn-DK', 'sgn-NL', 'sgn-EC', 'sgn-SV', 'sgn-CA-NU', 'sgn-ET', 'sgn-FI', 'sgn-CA-QC', 'sgn-FR', 'sgn-DE', 'sgn-GH', 'sgn-GR', 'sgn-GT', 'sgn-US-HI', 'sgn-HK', 'sgn-IS', 'sgn-ID', 'sgn-IN', 'sgn-IE', 'sgn-IL', 'sgn-IT', 'sgn-JM', 'sgn-JP', 'sgn-JO', 'sgn-KE', 'sgn-KR', 'sgn-MY-B', 'sgn-LV', 'sgn-LY', 'sgn-LT', 'sgn-FR-69', 'sgn-MY', 'sgn-MT', 'sgn-US-MA', 'sgn-MX-YUC', 'sgn-MX', 'sgn-VA', 'sgn-MN', 'sgn-MA', 'sgn-NA', 'sgn-NP', 'sgn-NZ', 'sgn-NI', 'sgn-NG', 'sgn-NO', 'sgn-CA-NS', 'sgn-GB-KEN', 'sgn-MY-P', 'sgn-IR', 'sgn-PE', 'sgn-PH', 'sgn-US-SD', 'sgn-PL', 'sgn-PT', 'sgn-CO-SAP', 'sgn-PR', 'sgn-SB', 'sgn-RO', 'sgn-RU', 'sgn-SA', 'sgn-SE-crp', 'sgn-SG', 'sgn-SK', 'sgn-ZA', 'sgn-ES', 'sgn-LK', 'sgn-SE', 'sgn-CH-GE', 'sgn-CH-ZH', 'sgn-CH-TI', 'sgn-TW', 'sgn-TZ', 'sgn-TH', 'sgn-TN', 'sgn-TR', 'sgn-UG', 'sgn-UA', 'sgn-BR-MA', 'sgn-UY', 'sgn-VE', 'sgn-IL-yid', 'sgn-YU', 'sgn-ZM', 'sgn-ZW', 'sgn-afr-ZA', 'sgn-chi-TW', 'sgn-dan-DK', 'sgn-dut-BE', 'sgn-dut-NL', 'sgn-eng-GB', 'sgn-eng-IE', 'sgn-eng-US', 'sgn-fin-FI', 'sgn-fre-BE', 'sgn-fre-CA', 'sgn-fre-FR', 'sgn-jpn-JP', 'sgn-nor-NO', 'sgn-por-PT', 'sgn-swe-SE'];
/**
 * We assume that IETF language tags will be extended with sign language codes (as proposed by
 * http://www.evertype.com/standards/iso639/sign-language.html) eventually, so our language tags
 * support them already.
 *
 * For sign language translations of strings, you can use media URLs pointing to videos or
 * description pictures.
 */

const ietfLanguageTagsAndSignLanguageCodes = ietfLanguageTags.concat(signLanguageCodes);

/**
 * The StaffSchema allows easy validation, cleaning and checking of Staff objects.
 */

const StaffSchema = new SimpleSchema({
  canSeeVisitorsFromInside: {
    type: Boolean,
    label: t`See From Inside`,
    accessibility: {
      question: t`Can the staff see visitors arriving?`,
      description: t`e.g. via a greeter or reception, a window or a always-monitored camera system`
    },
    optional: true
  },
  isTrainedInSigning: {
    type: Boolean,
    label: t`Signing training`,
    accessibility: {
      question: t`Is the staff trained in local sign languages?`
    },
    optional: true
  },
  hasFreeAssistantForVisitors: {
    type: Boolean,
    label: t`Visitor Assistant`,
    accessibility: {
      question: t`Is there a free assistant for visitors?`
    },
    optional: true
  },
  spokenLanguages: {
    type: Array,
    defaultValue: [],
    optional: true,
    accessibility: {
      question: t`Which languages do the staff speak (including sign language variants)?`
    }
  },
  'spokenLanguages.$': {
    type: String,
    label: t`Language`,
    allowedValues: ietfLanguageTagsAndSignLanguageCodes
  }
});

/**
 * The WheelchairPlacesSchema allows easy validation, cleaning and checking of WheelchairPlaces objects.
 */

const WheelchairPlacesSchema = new SimpleSchema({
  count: {
    type: SimpleSchema.Integer,
    label: t`Number Of Places`,
    accessibility: {
      question: t`How many wheelchair places are there?`
    },
    min: 0
  },
  hasSpaceForAssistant: {
    type: Boolean,
    label: t`Assistant Space`,
    accessibility: {
      question: t`Is there additional space for an assistant for each seat?`
    },
    optional: true
  }
});

const MediaSchema = new SimpleSchema({
  type: {
    type: String,
    label: t`Media Type`,
    allowedValues: ['document', 'menu', 'guide', 'presentation', 'exhibit', 'movie', 'play', 'screen'],
    accessibility: {
      question: t`What kind of media is described?`,
      options: [{
        value: 'document',
        label: t`document`
      }, {
        value: 'menu',
        label: t`menu`
      }, {
        value: 'guide',
        label: t`guide`
      }, {
        value: 'presentation',
        label: t`presentation`
      }, {
        value: 'exhibit',
        label: t`exhibit`
      }, {
        value: 'movie',
        label: t`movie`
      }, {
        value: 'screen',
        label: t`screen`
      }]
    }
  },
  name: {
    type: LocalizedStringSchema,
    label: t`Media Name`,
    optional: true,
    accessibility: {
      question: t`What the name of the`,
      description: t`e.g. 'daily menu' or 'park guide'`
    }
  },
  isBraille: {
    type: Boolean,
    label: t`Braille`,
    optional: true,
    accessibility: {
      question: t`Is there a braille version available?`
    }
  },
  isAudio: {
    type: Boolean,
    label: t`Audio`,
    optional: true,
    accessibility: {
      question: t`Is there an audio version available?`
    }
  },
  isLargePrint: {
    type: Boolean,
    label: t`Large Print`,
    optional: true,
    accessibility: {
      question: t`Is there a large print version available?`
    }
  },
  hasContrastingBackground: {
    type: Boolean,
    label: t`Contrasting Background`,
    optional: true,
    accessibility: {
      question: t`Is the print on a contrasting background?`
    }
  },
  hasDedicatedScreenForSubtitles: {
    type: Boolean,
    label: t`Dedicated Subtitle Screen`,
    optional: true,
    accessibility: {
      question: t`Is there a dedicated screen for subtitles.`
    }
  },
  hasSubtitles: {
    type: Boolean,
    label: t`Subtitles`,
    optional: true,
    accessibility: {
      question: t`Are there subtitles?`
    }
  },
  hasRealTimeCaptioning: {
    type: Boolean,
    label: t`Real-time Captioning`,
    optional: true,
    accessibility: {
      question: t`Is there real time captioning?`
    }
  },
  // There are no standardized language codes for this yet, so this needs to be an extra flag for now.
  hasPlainLanguageOption: {
    type: Boolean,
    label: t`Plain Language Option`,
    optional: true,
    accessibility: {
      question: t`Is there a plain language option?`
    }
  },
  languages: {
    type: Array,
    label: t`Languages`,
    optional: true,
    accessibility: {
      question: t`What are the available languages?`
    }
  },
  'languages.$': {
    type: String,
    label: t`Language`,
    allowedValues: ietfLanguageTagsAndSignLanguageCodes
  },
  turningSpaceInFront: quantityDefinition(LengthSchema, true, {
    question: t`How much space for turning is in front of the media?`
  })
});

const PaymentSchema = new SimpleSchema({
  hasPortablePaymentSystem: {
    type: Boolean,
    label: t`Portable Payment System`,
    optional: true,
    accessibility: {
      question: t`Is there a portable payment system?`
    }
  },
  acceptsPaymentByMobilePhone: {
    type: Boolean,
    label: t`Mobile Phone Payment`,
    optional: true,
    accessibility: {
      question: t`Is payment by mobile phone accepted?`
    }
  },
  acceptsCreditCards: {
    type: Boolean,
    label: t`Credit Cards`,
    optional: true,
    accessibility: {
      question: t`Is payment by credit card accepted?`
    }
  },
  acceptsDebitCards: {
    type: Boolean,
    label: t`Debit Cards`,
    optional: true,
    accessibility: {
      question: t`Is payment by debit card accepted?`
    }
  },
  acceptsCoins: {
    type: Boolean,
    label: t`Coins`,
    optional: true,
    accessibility: {
      question: t`Is payment by coins accepted?`
    }
  },
  acceptsBills: {
    type: Boolean,
    label: t`Bills`,
    optional: true,
    accessibility: {
      question: t`Is payment by bills accepted?`
    }
  },
  customPaymentMetaInfo: {
    type: Array,
    label: t`Custom Payment Information`,
    optional: true,
    accessibility: {
      question: t`Is there custom payment information?`,
      questionMore: t`Is there additional custom payment information?`,
      description: t`e.g. additional phone numbers, parking lot IDs etc.`
    }
  },
  'customPaymentMetaInfo.$': {
    type: LocalizedStringSchema,
    label: t`Custom Payment Information`,
    accessibility: {
      question: t`What is the custom information?`
    }
  }
});

const TablesSchema = new SimpleSchema({
  height: quantityDefinition(LengthSchema, true, {
    question: t`How high is the table?`
  }),
  spaceBelowHeight: quantityDefinition(LengthSchema, false, {
    question: t`How high is the free space below the table?`
  }),
  spaceBelowWidth: quantityDefinition(LengthSchema, false, {
    question: t`How wide is the free space below the table?`
  }),
  spaceBelowDepth: quantityDefinition(LengthSchema, false, {
    question: t`How deep is the free space below the table?`
  })
});
const AccessibleTablesPrefab = {
  height: {
    operator: '>=',
    value: 72,
    unit: 'cm'
  },
  spaceBelowHeight: {
    operator: '>=',
    value: 70,
    unit: 'cm'
  },
  spaceBelowWidth: {
    operator: '>=',
    value: 80,
    unit: 'cm'
  },
  spaceBelowDepth: {
    operator: '>=',
    value: 50,
    unit: 'cm'
  }
};

// https://register.apple.com/resources/imdf/Relationship/
// and
// https://docs.google.com/document/d/1qJOTe4m_a4dcJnvXYt4smYj4QQ1ejZ8CvLBYzDM5IyM

const PathwaysSchema = new SimpleSchema({
  width: quantityDefinition(LengthSchema, true, {
    question: t`How wide are the aisles or pathways?`
  }),
  widthAtObstacles: quantityDefinition(LengthSchema, true, {
    question: t`What is the minimum width at obstacles?`
  }),
  maxLongitudinalSlope: {
    type: Number,
    optional: true,
    accessibility: {
      question: t`What is the angle of the longitudinal slope?`,
      description: t`Grade in percent as calculated by \`100 * rise / run\` or the tangent of the angle of inclination, multiplied by 100`
    }
  },
  maxLateralSlope: {
    type: Number,
    optional: true,
    accessibility: {
      question: t`What is the angle of the lateral slope?`,
      description: t`Grade in percent as calculated by \`100 * rise / run\` or the tangent of the angle of inclination, multiplied by 100`
    }
  }
});

const WheelchairParkingSchema = new SimpleSchema({
  location: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`Where is the parking located?`
    }
  },
  distanceToEntrance: quantityDefinition(LengthSchema, true, {
    question: t`How far away is the parking from the main entrance?`
  }),
  count: {
    type: Number,
    optional: true,
    accessibility: {
      question: t`How many wheelchair accessible parking spaces are there?`
    },
    min: 0
  },
  isLocatedInside: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Are the parking spaces located inside?`
    }
  },
  width: quantityDefinition(LengthSchema, true, {
    question: t`How wide are the parking spaces?`
  }),
  length: quantityDefinition(LengthSchema, true, {
    question: t`How long are the parking spaces?`
  }),
  maxVehicleHeight: quantityDefinition(LengthSchema, true, {
    question: t`What is the max vehicle height of the parking spaces?`
  }),
  hasDedicatedSignage: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there dedicated disabled parking signage?`
    }
  },
  paymentBySpace: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there payment by parking space?`
    }
  },
  paymentByZone: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is there payment by parking zone?`
    }
  },
  neededParkingPermits: {
    type: Array,
    optional: true,
    accessibility: {
      question: t`Are any special parking permits required?`
    }
  },
  'neededParkingPermits.$': {
    type: LocalizedStringSchema,
    accessibility: {
      question: t`Which permit is needed?`
    }
  }
});
const ParkingSchema = new SimpleSchema({
  forWheelchairUsers: {
    type: WheelchairParkingSchema,
    optional: true,
    accessibility: {
      question: t`Is there parking for wheelchair users?`
    }
  },
  count: {
    type: Number,
    optional: true,
    accessibility: {
      question: t`How many parking spaces are there?`
    },
    min: 0
  }
});

const GroundSchema = new SimpleSchema({
  sidewalkConditions: {
    type: Number,
    optional: true,
    min: 0,
    max: 1,
    accessibility: {
      question: t`How would you rate the conditions of the sidewalk?`,
      componentHint: 'StarRating'
    }
  },
  isLevel: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the ground level?`
    }
  },
  slopeAngle: {
    type: Number,
    optional: true,
    accessibility: {
      description: t`Grade in percent as calculated by \`100 * rise / run\` or the tangent of the angle of inclination times 100`,
      question: t`What is the angle of the slope?`
    }
  },
  evenPavement: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the pavement even, ie. no cobble stones?`
    }
  },
  distanceToDroppedCurb: quantityDefinition(LengthSchema, true, {
    question: t`How far is the entrance from the next dropped curb?`
  }),
  turningSpace: quantityDefinition(LengthSchema, true, {
    question: t`How much space for turning is there?`
  })
});

const AnimalPolicySchema = new SimpleSchema({
  allowsGuideDogs: {
    type: Boolean,
    accessibility: {
      question: t`Does this place allow guide dogs?`
    }
  },
  allowsServiceAnimals: {
    type: Boolean,
    accessibility: {
      question: t`Does this place allow therapy animals?`
    }
  },
  allowsDogs: {
    type: Boolean,
    accessibility: {
      question: t`Does this place allow visitors to bring dogs?`
    }
  },
  dogsNeedMuzzle: {
    type: Boolean,
    accessibility: {
      question: t`Does this place enforce that dogs wear a muzzle?`
    }
  },
  allowsAnyPets: {
    type: Boolean,
    accessibility: {
      question: t`Does this place allow any kind of pets?`
    }
  },
  suppliesWaterForPets: {
    type: Boolean,
    accessibility: {
      question: t`Does this place supply water for pets?`
    }
  }
});

const smokingPolicies = [{
  label: t`dedicated to smoking`,
  value: 'dedicatedToSmoking'
}, {
  label: t`allowed everywhere`,
  value: 'allowedEverywhere'
}, {
  label: t`only allowed in separate (but not isolated) area`,
  value: 'inSeparateArea'
}, {
  label: t`only allowed in isolated area`,
  value: 'inIsolatedArea'
}, {
  label: t`prohibited`,
  value: 'prohibited'
}, {
  label: t`only outside`,
  value: 'onlyOutside'
}];

const WifiAccessibilitySchema = createSchemaInstance('WifiAccessibility', {
  isOpenToEveryone: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this wifi open to everyone?`
    }
  },
  isOpenToVisitors: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this wifi open to visitors?`
    }
  },
  isOpenToStaff: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this wifi open to staff?`
    }
  },
  hasFixedPassword: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does this wifi have a fixed password?`
    }
  },
  needsGuestPass: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Do you need a guest pass to use this wifi?`
    }
  },
  hasCaptivePortal: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Do you need to pass a captive portal to use this wifi?`
    }
  },
  isCaptivePortalAccessible: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`If there is a captive portal, is the captive portal website accessible (WAI/ARIA)?`
    }
  },
  ssid: {
    type: String,
    optional: true,
    accessibility: {
      question: t`What is the name/SSID of this wifi? Only enter this if it's okay to publish this information publicly.`
    }
  },
  password: {
    type: String,
    optional: true,
    accessibility: {
      question: t`What is the password of this wifi? Only enter this if it's okay to publish this information publicly.`
    }
  },
  descriptionWhereToGetLoginData: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`Where can you find the login data for this wifi, or get a guest pass?`
    }
  }
});

const AccessibilitySchema = new SimpleSchema({
  accessibleWith: {
    type: PersonalProfileSchema,
    optional: true,
    accessibility: {
      deprecated: true
    }
  },
  partiallyAccessibleWith: {
    type: PersonalProfileSchema,
    optional: true,
    accessibility: {
      deprecated: true
    }
  },
  offersActivitiesForPeopleWith: {
    type: PersonalProfileSchema,
    optional: true,
    accessibility: {
      deprecated: true
    }
  },
  staff: {
    type: StaffSchema,
    optional: true,
    accessibility: {
      question: t`Is there any staff on the premises?`
    }
  },
  wheelchairPlaces: {
    type: WheelchairPlacesSchema,
    optional: true,
    accessibility: {
      question: t`Are there any spaces reserved for people in wheelchairs?`
    }
  },
  media: {
    type: Array,
    optional: true,
    accessibility: {
      question: t`Is there any media available?`,
      questionMore: t`Is there more media available?`,
      description: t`e.g. menus, exhibits or presentations`
    }
  },
  'media.$': {
    type: MediaSchema
  },
  payment: {
    type: PaymentSchema,
    optional: true,
    accessibility: {
      question: t`Is there any payment possible?`
    }
  },
  parking: {
    type: ParkingSchema,
    optional: true,
    accessibility: {
      question: t`Is there parking attached to this place?`
    }
  },
  ground: {
    type: GroundSchema,
    optional: true,
    accessibility: {
      question: t`In which condition is the ground you have to traverse to get here?`
    }
  },
  wifi: {
    type: WifiAccessibilitySchema,
    optional: true,
    accessibility: {
      question: t`Is there a local wifi?`
    }
  },
  ratingSpacious: {
    type: Number,
    optional: true,
    min: 0,
    max: 1,
    accessibility: {
      deprecated: true,
      question: t`How spacious is this place?`,
      componentHint: 'StarRating'
    }
  },
  isWellLit: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the place well lit?`
    }
  },
  isQuiet: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the place quiet?`
    }
  },
  hasInductionLoop: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Does this place have induction loops?`
    }
  },
  // TODO: Causes test error. Fix this!
  // ambientNoiseLevel: quantityDefinition(LengthSchema, true, {
  //   question: t`How loud is the ambient noise here typically (A-Weighted)?`,
  //   machineData: true
  // }),
  smokingPolicy: {
    type: String,
    optional: true,
    allowedValues: smokingPolicies.map(s => s.value),
    accessibility: {
      question: t`Is smoking allowed here?`,
      options: smokingPolicies
    }
  },
  hasTactileGuideStrips: {
    type: Boolean,
    optional: true
  },
  animalPolicy: {
    type: AnimalPolicySchema,
    optional: true,
    accessibility: {
      question: t`What is the animal policy of this place?`
    }
  },
  pathways: {
    type: PathwaysSchema,
    optional: true
  },
  entrances: {
    type: Array,
    optional: true,
    label: t`Entrances`,
    accessibility: {
      questionBlockBegin: t`Would you like to rate the first entrance?`,
      questionMore: t`Would you like to rate another entrance?`
    }
  },
  'entrances.$': EntranceSchema,
  restrooms: {
    type: Array,
    optional: true,
    label: t`Restrooms`,
    accessibility: {
      questionBlockBegin: t`Would you like to rate the accessibility of the restroom?`,
      questionMore: t`Would you like to rate another restroom?`
    }
  },
  'restrooms.$': RestroomSchema,
  tables: {
    type: TablesSchema,
    optional: true,
    accessibility: {
      question: t`Are there any tables here?`,
      options: [{
        label: t`Accessible table`,
        option: AccessibleTablesPrefab
      }]
    }
  },
  sitemap: {
    type: Object,
    optional: true
  },
  lifts: {
    type: Array,
    optional: true
  },
  'lifts.$': Object,
  switches: {
    type: Array,
    optional: true
  },
  'switches.$': Object,
  vendingMachines: {
    type: Array,
    optional: true
  },
  'vendingMachines.$': Object,
  powerOutlets: {
    type: Array,
    optional: true
  },
  'powerOutlets.$': Object,
  beds: {
    type: Array,
    optional: true
  },
  'beds.$': Object,
  wardrobe: {
    type: Object,
    optional: true
  },
  changingRoom: {
    type: Object,
    optional: true
  },
  stage: {
    type: Object,
    optional: true
  },
  cashRegister: {
    type: Object,
    optional: true
  },
  seats: {
    type: Object,
    optional: true
  },
  serviceContact: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`How can the service staff be reached?`
    }
  },
  services: {
    type: Object,
    optional: true
  },
  infoDesk: {
    type: Object,
    optional: true
  },
  signage: {
    type: Object,
    optional: true
  }
});

/**
 * All existing ISO 3166-1 alpha-3 country codes
 */

const isoAlphaThreeCountryCodes = [{
  value: 'ABW',
  label: t`Aruba`
}, {
  value: 'AFG',
  label: t`Afghanistan`
}, {
  value: 'AGO',
  label: t`Angola`
}, {
  value: 'AIA',
  label: t`Anguilla`
}, {
  value: 'ALA',
  label: t`Åland Islands`
}, {
  value: 'ALB',
  label: t`Albania`
}, {
  value: 'AND',
  label: t`Andorra`
}, {
  value: 'ARE',
  label: t`United Arab Emirates`
}, {
  value: 'ARG',
  label: t`Argentina`
}, {
  value: 'ARM',
  label: t`Armenia`
}, {
  value: 'ASM',
  label: t`American Samoa`
}, {
  value: 'ATA',
  label: t`Antarctica`
}, {
  value: 'ATF',
  label: t`French Southern Territories`
}, {
  value: 'ATG',
  label: t`Antigua and Barbuda`
}, {
  value: 'AUS',
  label: t`Australia`
}, {
  value: 'AUT',
  label: t`Austria`
}, {
  value: 'AZE',
  label: t`Azerbaijan`
}, {
  value: 'BDI',
  label: t`Burundi`
}, {
  value: 'BEL',
  label: t`Belgium`
}, {
  value: 'BEN',
  label: t`Benin`
}, {
  value: 'BES',
  label: t`Bonaire, Sint Eustatius and Saba`
}, {
  value: 'BFA',
  label: t`Burkina Faso`
}, {
  value: 'BGD',
  label: t`Bangladesh`
}, {
  value: 'BGR',
  label: t`Bulgaria`
}, {
  value: 'BHR',
  label: t`Bahrain`
}, {
  value: 'BHS',
  label: t`Bahamas`
}, {
  value: 'BIH',
  label: t`Bosnia and Herzegovina`
}, {
  value: 'BLM',
  label: t`Saint Barthélemy`
}, {
  value: 'BLR',
  label: t`Belarus`
}, {
  value: 'BLZ',
  label: t`Belize`
}, {
  value: 'BMU',
  label: t`Bermuda`
}, {
  value: 'BOL',
  label: t`Bolivia, Plurinational State of`
}, {
  value: 'BRA',
  label: t`Brazil`
}, {
  value: 'BRB',
  label: t`Barbados`
}, {
  value: 'BRN',
  label: t`Brunei Darussalam`
}, {
  value: 'BTN',
  label: t`Bhutan`
}, {
  value: 'BVT',
  label: t`Bouvet Island`
}, {
  value: 'BWA',
  label: t`Botswana`
}, {
  value: 'CAF',
  label: t`Central African Republic`
}, {
  value: 'CAN',
  label: t`Canada`
}, {
  value: 'CCK',
  label: t`Cocos (Keeling) Islands`
}, {
  value: 'CHE',
  label: t`Switzerland`
}, {
  value: 'CHL',
  label: t`Chile`
}, {
  value: 'CHN',
  label: t`China`
}, {
  value: 'CIV',
  label: t`Côte d'Ivoire`
}, {
  value: 'CMR',
  label: t`Cameroon`
}, {
  value: 'COD',
  label: t`Congo, the Democratic Republic of the`
}, {
  value: 'COG',
  label: t`Congo`
}, {
  value: 'COK',
  label: t`Cook Islands`
}, {
  value: 'COL',
  label: t`Colombia`
}, {
  value: 'COM',
  label: t`Comoros`
}, {
  value: 'CPV',
  label: t`Cabo Verde`
}, {
  value: 'CRI',
  label: t`Costa Rica`
}, {
  value: 'CUB',
  label: t`Cuba`
}, {
  value: 'CUW',
  label: t`Curaçao`
}, {
  value: 'CXR',
  label: t`Christmas Island`
}, {
  value: 'CYM',
  label: t`Cayman Islands`
}, {
  value: 'CYP',
  label: t`Cyprus`
}, {
  value: 'CZE',
  label: t`Czechia`
}, {
  value: 'DEU',
  label: t`Germany`
}, {
  value: 'DJI',
  label: t`Djibouti`
}, {
  value: 'DMA',
  label: t`Dominica`
}, {
  value: 'DNK',
  label: t`Denmark`
}, {
  value: 'DOM',
  label: t`Dominican Republic`
}, {
  value: 'DZA',
  label: t`Algeria`
}, {
  value: 'ECU',
  label: t`Ecuador`
}, {
  value: 'EGY',
  label: t`Egypt`
}, {
  value: 'ERI',
  label: t`Eritrea`
}, {
  value: 'ESH',
  label: t`Western Sahara`
}, {
  value: 'ESP',
  label: t`Spain`
}, {
  value: 'EST',
  label: t`Estonia`
}, {
  value: 'ETH',
  label: t`Ethiopia`
}, {
  value: 'FIN',
  label: t`Finland`
}, {
  value: 'FJI',
  label: t`Fiji`
}, {
  value: 'FLK',
  label: t`Falkland Islands (Malvinas)`
}, {
  value: 'FRA',
  label: t`France`
}, {
  value: 'FRO',
  label: t`Faroe Islands`
}, {
  value: 'FSM',
  label: t`Micronesia, Federated States of`
}, {
  value: 'GAB',
  label: t`Gabon`
}, {
  value: 'GBR',
  label: t`United Kingdom`
}, {
  value: 'GEO',
  label: t`Georgia`
}, {
  value: 'GGY',
  label: t`Guernsey`
}, {
  value: 'GHA',
  label: t`Ghana`
}, {
  value: 'GIB',
  label: t`Gibraltar`
}, {
  value: 'GIN',
  label: t`Guinea`
}, {
  value: 'GLP',
  label: t`Guadeloupe`
}, {
  value: 'GMB',
  label: t`Gambia`
}, {
  value: 'GNB',
  label: t`Guinea-Bissau`
}, {
  value: 'GNQ',
  label: t`Equatorial Guinea`
}, {
  value: 'GRC',
  label: t`Greece`
}, {
  value: 'GRD',
  label: t`Grenada`
}, {
  value: 'GRL',
  label: t`Greenland`
}, {
  value: 'GTM',
  label: t`Guatemala`
}, {
  value: 'GUF',
  label: t`French Guiana`
}, {
  value: 'GUM',
  label: t`Guam`
}, {
  value: 'GUY',
  label: t`Guyana`
}, {
  value: 'HKG',
  label: t`Hong Kong`
}, {
  value: 'HMD',
  label: t`Heard Island and McDonald Islands`
}, {
  value: 'HND',
  label: t`Honduras`
}, {
  value: 'HRV',
  label: t`Croatia`
}, {
  value: 'HTI',
  label: t`Haiti`
}, {
  value: 'HUN',
  label: t`Hungary`
}, {
  value: 'IDN',
  label: t`Indonesia`
}, {
  value: 'IMN',
  label: t`Isle of Man`
}, {
  value: 'IND',
  label: t`India`
}, {
  value: 'IOT',
  label: t`British Indian Ocean Territory`
}, {
  value: 'IRL',
  label: t`Ireland`
}, {
  value: 'IRN',
  label: t`Iran, Islamic Republic of`
}, {
  value: 'IRQ',
  label: t`Iraq`
}, {
  value: 'ISL',
  label: t`Iceland`
}, {
  value: 'ISR',
  label: t`Israel`
}, {
  value: 'ITA',
  label: t`Italy`
}, {
  value: 'JAM',
  label: t`Jamaica`
}, {
  value: 'JEY',
  label: t`Jersey`
}, {
  value: 'JOR',
  label: t`Jordan`
}, {
  value: 'JPN',
  label: t`Japan`
}, {
  value: 'KAZ',
  label: t`Kazakhstan`
}, {
  value: 'KEN',
  label: t`Kenya`
}, {
  value: 'KGZ',
  label: t`Kyrgyzstan`
}, {
  value: 'KHM',
  label: t`Cambodia`
}, {
  value: 'KIR',
  label: t`Kiribati`
}, {
  value: 'KNA',
  label: t`Saint Kitts and Nevis`
}, {
  value: 'KOR',
  label: t`Korea, Republic of`
}, {
  value: 'KWT',
  label: t`Kuwait`
}, {
  value: 'LAO',
  label: t`Lao People's Democratic Republic`
}, {
  value: 'LBN',
  label: t`Lebanon`
}, {
  value: 'LBR',
  label: t`Liberia`
}, {
  value: 'LBY',
  label: t`Libya`
}, {
  value: 'LCA',
  label: t`Saint Lucia`
}, {
  value: 'LIE',
  label: t`Liechtenstein`
}, {
  value: 'LKA',
  label: t`Sri Lanka`
}, {
  value: 'LSO',
  label: t`Lesotho`
}, {
  value: 'LTU',
  label: t`Lithuania`
}, {
  value: 'LUX',
  label: t`Luxembourg`
}, {
  value: 'LVA',
  label: t`Latvia`
}, {
  value: 'MAC',
  label: t`Macao`
}, {
  value: 'MAF',
  label: t`Saint Martin (French part)`
}, {
  value: 'MAR',
  label: t`Morocco`
}, {
  value: 'MCO',
  label: t`Monaco`
}, {
  value: 'MDA',
  label: t`Moldova, Republic of`
}, {
  value: 'MDG',
  label: t`Madagascar`
}, {
  value: 'MDV',
  label: t`Maldives`
}, {
  value: 'MEX',
  label: t`Mexico`
}, {
  value: 'MHL',
  label: t`Marshall Islands`
}, {
  value: 'MKD',
  label: t`Macedonia, the former Yugoslav Republic of`
}, {
  value: 'MLI',
  label: t`Mali`
}, {
  value: 'MLT',
  label: t`Malta`
}, {
  value: 'MMR',
  label: t`Myanmar`
}, {
  value: 'MNE',
  label: t`Montenegro`
}, {
  value: 'MNG',
  label: t`Mongolia`
}, {
  value: 'MNP',
  label: t`Northern Mariana Islands`
}, {
  value: 'MOZ',
  label: t`Mozambique`
}, {
  value: 'MRT',
  label: t`Mauritania`
}, {
  value: 'MSR',
  label: t`Montserrat`
}, {
  value: 'MTQ',
  label: t`Martinique`
}, {
  value: 'MUS',
  label: t`Mauritius`
}, {
  value: 'MWI',
  label: t`Malawi`
}, {
  value: 'MYS',
  label: t`Malaysia`
}, {
  value: 'MYT',
  label: t`Mayotte`
}, {
  value: 'NAM',
  label: t`Namibia`
}, {
  value: 'NCL',
  label: t`New Caledonia`
}, {
  value: 'NER',
  label: t`Niger`
}, {
  value: 'NFK',
  label: t`Norfolk Island`
}, {
  value: 'NGA',
  label: t`Nigeria`
}, {
  value: 'NIC',
  label: t`Nicaragua`
}, {
  value: 'NIU',
  label: t`Niue`
}, {
  value: 'NLD',
  label: t`Netherlands`
}, {
  value: 'NOR',
  label: t`Norway`
}, {
  value: 'NPL',
  label: t`Nepal`
}, {
  value: 'NRU',
  label: t`Nauru`
}, {
  value: 'NZL',
  label: t`New Zealand`
}, {
  value: 'OMN',
  label: t`Oman`
}, {
  value: 'PAK',
  label: t`Pakistan`
}, {
  value: 'PAN',
  label: t`Panama`
}, {
  value: 'PCN',
  label: t`Pitcairn`
}, {
  value: 'PER',
  label: t`Peru`
}, {
  value: 'PHL',
  label: t`Philippines`
}, {
  value: 'PLW',
  label: t`Palau`
}, {
  value: 'PNG',
  label: t`Papua New Guinea`
}, {
  value: 'POL',
  label: t`Poland`
}, {
  value: 'PRI',
  label: t`Puerto Rico`
}, {
  value: 'PRK',
  label: t`Korea, Democratic People's Republic of`
}, {
  value: 'PRT',
  label: t`Portugal`
}, {
  value: 'PRY',
  label: t`Paraguay`
}, {
  value: 'PSE',
  label: t`Palestine, State of`
}, {
  value: 'PYF',
  label: t`French Polynesia`
}, {
  value: 'QAT',
  label: t`Qatar`
}, {
  value: 'REU',
  label: t`Réunion`
}, {
  value: 'ROU',
  label: t`Romania`
}, {
  value: 'RUS',
  label: t`Russian Federation`
}, {
  value: 'RWA',
  label: t`Rwanda`
}, {
  value: 'SAU',
  label: t`Saudi Arabia`
}, {
  value: 'SDN',
  label: t`Sudan`
}, {
  value: 'SEN',
  label: t`Senegal`
}, {
  value: 'SGP',
  label: t`Singapore`
}, {
  value: 'SGS',
  label: t`South Georgia and the South Sandwich Islands`
}, {
  value: 'SHN',
  label: t`Saint Helena, Ascension and Tristan da Cunha`
}, {
  value: 'SJM',
  label: t`Svalbard and Jan Mayen`
}, {
  value: 'SLB',
  label: t`Solomon Islands`
}, {
  value: 'SLE',
  label: t`Sierra Leone`
}, {
  value: 'SLV',
  label: t`El Salvador`
}, {
  value: 'SMR',
  label: t`San Marino`
}, {
  value: 'SOM',
  label: t`Somalia`
}, {
  value: 'SPM',
  label: t`Saint Pierre and Miquelon`
}, {
  value: 'SRB',
  label: t`Serbia`
}, {
  value: 'SSD',
  label: t`South Sudan`
}, {
  value: 'STP',
  label: t`Sao Tome and Principe`
}, {
  value: 'SUR',
  label: t`Suriname`
}, {
  value: 'SVK',
  label: t`Slovakia`
}, {
  value: 'SVN',
  label: t`Slovenia`
}, {
  value: 'SWE',
  label: t`Sweden`
}, {
  value: 'SWZ',
  label: t`Swaziland`
}, {
  value: 'SXM',
  label: t`Sint Maarten (Dutch part)`
}, {
  value: 'SYC',
  label: t`Seychelles`
}, {
  value: 'SYR',
  label: t`Syrian Arab Republic`
}, {
  value: 'TCA',
  label: t`Turks and Caicos Islands`
}, {
  value: 'TCD',
  label: t`Chad`
}, {
  value: 'TGO',
  label: t`Togo`
}, {
  value: 'THA',
  label: t`Thailand`
}, {
  value: 'TJK',
  label: t`Tajikistan`
}, {
  value: 'TKL',
  label: t`Tokelau`
}, {
  value: 'TKM',
  label: t`Turkmenistan`
}, {
  value: 'TLS',
  label: t`Timor-Leste`
}, {
  value: 'TON',
  label: t`Tonga`
}, {
  value: 'TTO',
  label: t`Trinidad and Tobago`
}, {
  value: 'TUN',
  label: t`Tunisia`
}, {
  value: 'TUR',
  label: t`Turkey`
}, {
  value: 'TUV',
  label: t`Tuvalu`
}, {
  value: 'TWN',
  label: t`Taiwan, Province of China`
}, {
  value: 'TZA',
  label: t`Tanzania, United Republic of`
}, {
  value: 'UGA',
  label: t`Uganda`
}, {
  value: 'UKR',
  label: t`Ukraine`
}, {
  value: 'UMI',
  label: t`United States Minor Outlying Islands`
}, {
  value: 'URY',
  label: t`Uruguay`
}, {
  value: 'USA',
  label: t`United States of America`
}, {
  value: 'UZB',
  label: t`Uzbekistan`
}, {
  value: 'VAT',
  label: t`Holy See`
}, {
  value: 'VCT',
  label: t`Saint Vincent and the Grenadines`
}, {
  value: 'VEN',
  label: t`Venezuela, Bolivarian Republic of`
}, {
  value: 'VGB',
  label: t`Virgin Islands, British`
}, {
  value: 'VIR',
  label: t`Virgin Islands, U.S.`
}, {
  value: 'VNM',
  label: t`VietNam`
}, {
  value: 'VUT',
  label: t`Vanuatu`
}, {
  value: 'WLF',
  label: t`Wallis and Futuna`
}, {
  value: 'WSM',
  label: t`Samoa`
}, {
  value: 'YEM',
  label: t`Yemen`
}, {
  value: 'ZAF',
  label: t`South Africa`
}, {
  value: 'ZMB',
  label: t`Zambia`
}, {
  value: 'ZWE',
  label: t`Zimbabwe`
}];

/**
 * The StructuredAddressSchema allows easy validation, cleaning and checking of structured address objects.
 */

const StructuredAddressSchema = new SimpleSchema({
  text: {
    label: t`Text`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`A displayable, formatted address as rich text (Markdown).`
    },
    optional: true
  },
  room: {
    label: t`Room`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`Room name`,
      question: t`What is the name of the room?`,
      example: t`e.g. meeting room 'Rome'`
    },
    optional: true
  },
  roomNumber: {
    label: t`Room number`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`Room number`,
      question: t`Does the room have a unique number?`,
      example: t`e.g. 'A204'`
    },
    optional: true
  },
  level: {
    label: t`Level`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`The number of the floor in british convention (ground floor is 0)`,
      question: t`What is the number of the floor?`,
      extendedInformationUrl: 'https://en.wikipedia.org/wiki/Storey',
      example: t`e.g. 4`
    },
    optional: true
  },
  building: {
    label: t`Building`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`Building name`,
      example: t`e.g. main exposition hall`
    },
    optional: true
  },
  house: {
    label: t`House`,
    type: LocalizedStringSchema,
    accessibility: {
      question: t`What is the house number?`
    },
    optional: true
  },
  street: {
    label: t`Street`,
    type: LocalizedStringSchema,
    accessibility: {
      question: t`What is the name of the street?`,
      description: t`Please avoid numbers for houses or buildings.`
    },
    optional: true
  },
  postalCode: {
    label: t`Postal Code`,
    type: LocalizedStringSchema,
    accessibility: {
      question: t`What is the postal code?`,
      description: t`Also called ZIP code.`
    },
    optional: true
  },
  areas: {
    label: t`Areas`,
    type: Array,
    accessibility: {
      description: t`An array of named areas below the district and above street. In some regions such areas might also contain street names, when individual street segments have names separate from the name of the whole road.`
    },
    optional: true
  },
  'areas.$': {
    type: LocalizedStringSchema
  },
  district: {
    label: t`District`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`A division of city; typically an administrative unit within a larger city or a customary name of a city\'s neighborhood.`,
      question: t`The place is located destrict…`
    },
    optional: true
  },
  city: {
    label: t`City`,
    type: LocalizedStringSchema,
    accessibility: {
      question: t`In which city is this place?`
    },
    optional: true
  },
  regions: {
    label: t`Regions`,
    type: Array,
    accessibility: {
      description: t`For address conventions where more than to levels of named areas above the city level are in use, the regions attribute provides an array with all additional area names, ordered by decreasing size (starting with the highest subdivision below state)`
    },
    optional: true
  },
  'regions.$': {
    type: LocalizedStringSchema
  },
  county: {
    label: t`County`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`A division of a state; typically a secondary-level administrative division of a country or equivalent.`
    },
    optional: true
  },
  state: {
    label: t`State`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`A division of a country; typically a first-level administrative division of a country and/or a geographical region.`
    },
    optional: true
  },
  stateCode: {
    label: t`State Code`,
    type: LocalizedStringSchema,
    accessibility: {
      description: t`A code/abbreviation for the state division of a country.`
    },
    optional: true
  },
  countryCode: {
    label: t`Country Code`,
    type: LocalizedStringSchema,
    optional: true,
    allowedValues: isoAlphaThreeCountryCodes.map(c => c.value),
    accessibility: {
      description: t`A three-letter country code in ISO 3166-1 alpha-3, see https://en.wikipedia.org/wiki/ISO_3166-1_alpha-3`,
      options: isoAlphaThreeCountryCodes
    }
  }
});
/**
 * The AddressSchema extends the StructuredAddressSchema and allows also Strings
 */

const AddressSchema = SimpleSchema.oneOf(StructuredAddressSchema, String);

const PointGeometrySchema = new SimpleSchema({
  type: {
    type: String,
    allowedValues: ['Point']
  },
  coordinates: {
    type: Array,
    minCount: 2,
    maxCount: 2
  },
  'coordinates.$': {
    type: Number,
    min: -180,
    max: 180
  }
});
const GeometrySchema = PointGeometrySchema;

const ExternalIdSchema = new SimpleSchema({
  provider: String,
  id: String,
  schemaName: {
    type: String,
    optional: true
  }
});

const AllowedEquipmentTypes = Object.freeze(['bed', 'wardrobe', 'elevator', 'escalator', 'movingWalkway', 'ramp', 'hoist', 'stairLift', 'switch', 'sitemap', 'vendingMachine', 'intercom', 'powerOutlet']);
const EquipmentPropertiesSchema = new SimpleSchema({
  ids: {
    type: Array,
    optional: true
  },
  'ids.$': ExternalIdSchema,
  originalId: {
    type: String,
    optional: true
  },
  category: {
    type: String,
    optional: true,
    allowedValues: AllowedEquipmentTypes.map(s => s)
  },
  description: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      description: t`Describes where the equipment is located. If only one description string is technically possible to maintain, it should not contain any abbreviations to allow being read aloud by screen readers or voice assistants`,
      example: t`For elevators: ‘Between ticket counter and Central Line platforms’, ‘From basement upwards towards Main Street exit’`
    }
  },
  // Alternative description that is screen-reader compatible and replaces abbreviations / symbols with words
  longDescription: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      description: t`Contains the same information as description, but in a longer form which can be read out by a screen reader or voice assistant.
        Words should be written out fully (e.g. ‘direction’ instead of ‘dir.‘, ‘ground’ instead of ‘G‘, ‘platform’ instead of ‘pl.’). The field should not contain any symbols (e.g. \`->\`, \`<->\`, or \`→\`).
        Suitable for people who have a visual impairment or use a screen reader or voice assistant (e.g. Amazon’s Alexa).
        If only one description field can be used for technical reasons, then the written-out form should be given preference, because a short form can be generated from the long form more easily than the other way around.
        Can be used by web developers as content for the \`aria-label\`-attribute, for example.`
    }
  },
  // Alternative description that uses less screen estate, more abbreviations and Unicode symbols like `→`
  shortDescription: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      description: t`Contains the same information as description, but in a shorter form, to save space on the screen. May contain Unicode characters such as ⟷ or ↘︎ as well as abbreviations (e.g. ‘pl.’ instead of ‘platform’, ‘dir.’ instead of ‘direction’).`
    }
  },
  heightOfControls: {
    type: LengthSchema,
    optional: true,
    accessibility: {
      componentHint: 'Unit',
      question: t`How high are the lowest working controls for this equipment?`
    }
  },
  door: {
    type: DoorSchema,
    optional: true,
    label: t`Door`,
    accessibility: {
      questionBlockBegin: t`Would you like to add information about the door of this equipment?`
    }
  },
  hasDoorsInBothDirections: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`If this is an elevator, does it have doors in both directions?`
    }
  },
  cabinWidth: {
    type: LengthSchema,
    optional: true,
    accessibility: {
      componentHint: 'Unit',
      question: t`How wide is the cabin (as seen from the entrance)?`
    }
  },
  cabinLength: {
    type: LengthSchema,
    optional: true,
    accessibility: {
      componentHint: 'Unit',
      question: t`How long/deep is the cabin (as seen from the entrance)?`
    }
  },
  languages: {
    type: Array,
    defaultValue: [],
    optional: true
  },
  'languages.$': {
    type: String,
    label: t`Language`,
    allowedValues: ietfLanguageTagsAndSignLanguageCodes
  },
  hasRaisedText: {
    type: Boolean,
    optional: true
  },
  hasBrailleText: {
    type: Boolean,
    optional: true
  },
  hasSpeech: {
    type: Boolean,
    optional: true
  },
  isHighContrast: {
    type: Boolean,
    optional: true
  },
  hasLargePrint: {
    type: Boolean,
    optional: true
  },
  isVoiceActivated: {
    type: Boolean,
    optional: true
  },
  hasHeadPhoneJack: {
    type: Boolean,
    optional: true
  },
  isEasyToUnderstand: {
    type: Boolean,
    optional: true
  },
  needsTouchScreenInput: {
    type: Boolean,
    optional: true
  },
  hasTouchScreenInput: {
    type: Boolean,
    optional: true
  },
  needsQRCodeScan: {
    type: Boolean,
    optional: true
  },
  hasQRCode: {
    type: Boolean,
    optional: true
  },
  needsHapticInput: {
    type: Boolean,
    optional: true
  },
  hasHapticInput: {
    type: Boolean,
    optional: true
  },
  needsVisualRecognition: {
    type: Boolean,
    optional: true
  },
  isIndoors: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is this equipment indoors?`
    }
  },
  alternativeRouteInstructions: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`Is there an alternative route to this equipment?`
    }
  },
  isWorking: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the equipment currently in operation?`,
      accessibility: {
        machineData: true
      }
    }
  },
  isAccessibleWithWheelchair: {
    type: Boolean,
    optional: true,
    accessibility: {
      question: t`Is the equipment accessible with a wheelchair?`,
      accessibility: {
        machineData: true
      }
    }
  },
  outOfOrderReason: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`If the equipment is not in operation, why?`,
      example: 'Vandalism, construction work, …',
      machineData: true
    }
  },
  stateLastUpdate: {
    type: Date,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Last update of the operational status`
    }
  },
  plannedCompletionDate: {
    type: Date,
    optional: true,
    accessibility: {
      question: t`If the equipment is not in operation, when is it going to be again?`
    }
  },
  manufacturerName: {
    type: LocalizedStringSchema,
    optional: true
  },
  manufacturerSerialNumber: {
    type: String,
    optional: true
  },
  servicePhoneNumber: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`Which phone number should be called to notify if the equipment is out of service?`,
      description: t`Service phone number under which the facility management can be reached, with international country code`,
      example: t`e.g. +1-555-555-90-210`,
      componentHint: 'PhoneNumber'
    }
  },
  serviceWebsiteUrl: {
    type: LocalizedStringSchema,
    regEx: SimpleSchema.RegEx.Url,
    optional: true,
    accessibility: {
      question: t`On which website address can you find updates about the operational status?`
    }
  },
  sourceId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Reference to the data source where this information comes from (accessibility.cloud ID)`
    }
  },
  sourceImportId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Reference to the data import where this information comes from (accessibility.cloud ID)`
    }
  },
  placeSourceId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Original ID of the place data source that this equipment belongs to (accessibility.cloud ID)`
    }
  },
  originalPlaceInfoId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Original ID of the place that this equipment belongs to (unique in the original data set)`
    }
  },
  disruptionSourceImportId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Reference to data source for operational status live updates (accessibility.cloud ID)`
    }
  },
  originalData: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Data record that came from the original data source (for debugging)`
    }
  },
  placeInfoId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true,
      description: t`Reference to the place that this equipment belongs to (accessibility.cloud ID)`
    }
  }
});

const EquipmentInfoSchema = new SimpleSchema({
  formatVersion: {
    type: String,
    optional: true
  },
  properties: {
    type: EquipmentPropertiesSchema
  },
  geometry: {
    type: PointGeometrySchema
  }
});

const PlacePropertiesSchema = new SimpleSchema({
  name: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`What is the name of this place?`
    }
  },
  category: {
    type: String,
    accessibility: {
      question: t`What type of place is this?`,
      componentHint: 'Category'
    }
  },
  address: {
    type: AddressSchema,
    optional: true,
    label: t`Address`,
    accessibility: {
      question: t`Would you like to add the address?`,
      componentHint: 'Address'
    }
  },
  description: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`How would you describe this place?`,
      componentHint: 'TextArea'
    }
  },
  phoneNumber: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`What is the phone number of this place?`,
      description: t`The phone number of this place, with international country code`,
      example: t`e.g. +1-555-555-90-210`,
      componentHint: 'PhoneNumber'
    }
  },
  emailAddress: {
    type: LocalizedStringSchema,
    optional: true,
    accessibility: {
      question: t`What is the email address of this place?`,
      description: t`An email address where visitors can get accessibility relevant information`,
      example: t`e.g. accessibility@example.com`
    }
  },
  accessibility: {
    type: AccessibilitySchema,
    optional: true,
    accessibility: {
      question: t`Okay, now let\`s map the accessibility.`,
      description: t`Describes the overall accessibility of a place.`
    }
  },
  infoPageUrl: {
    type: LocalizedStringSchema,
    regEx: SimpleSchema.RegEx.Url,
    optional: true,
    accessibility: {
      description: t`URL of the original data source’s website describing this place`
    }
  },
  editPageUrl: {
    type: LocalizedStringSchema,
    regEx: SimpleSchema.RegEx.Url,
    optional: true,
    accessibility: {
      description: t`URL of the original data source’s website on a subpage that allows to edit the original data.`
    }
  },
  placeWebsiteUrl: {
    type: LocalizedStringSchema,
    regEx: SimpleSchema.RegEx.Url,
    optional: true,
    accessibility: {
      description: t`URL of the place’s own website`
    }
  },
  // machine data fields
  ids: {
    type: Array,
    optional: true,
    accessibility: {
      machineData: true
    }
  },
  'ids.$': ExternalIdSchema,
  originalId: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true
    }
  },
  parentPlaceId: {
    type: String,
    optional: true,
    regEx: SimpleSchema.RegEx.Id,
    accessibility: {
      machineData: true
    }
  },
  originalData: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true
    }
  },
  eventId: {
    type: String,
    optional: true,
    regEx: SimpleSchema.RegEx.Id,
    accessibility: {
      machineData: true
    }
  },
  creatorId: {
    type: String,
    optional: true,
    regEx: SimpleSchema.RegEx.Id,
    accessibility: {
      machineData: true
    }
  },
  sourceId: {
    type: String,
    optional: true,
    regEx: SimpleSchema.RegEx.Id,
    accessibility: {
      machineData: true
    }
  },
  sourceImportId: {
    type: String,
    optional: true,
    regEx: SimpleSchema.RegEx.Id,
    accessibility: {
      machineData: true
    }
  }
});

/**
 * The PlaceInfoSchema allows easy validation, cleaning and checking of PlaceInfo objects.
 */

const PlaceInfoSchema = new SimpleSchema({
  formatVersion: {
    type: String,
    optional: true,
    accessibility: {
      machineData: true
    }
  },
  properties: {
    type: PlacePropertiesSchema,
    label: t`Properties`,
    accessibility: {
      question: t`First we need some information about the place.`
    }
  },
  geometry: {
    type: GeometrySchema,
    label: t`Place on map`,
    accessibility: {
      question: t`On the map, drag the place icon to the entrance's exact position.`,
      inseparable: true
    }
  }
});

/**
 *  Returns true if the given SimpleSchema definition contains a SimpleSchema instance
 */

const isDefinitionTypeSchema = definition => {
  const type = definition.type; // Check whether we need to handle multiple definitions & non SimpleSchemaGroups

  if (type && type.definitions && type.definitions[0] && SimpleSchema.isSimpleSchema(type.definitions[0].type)) {
    return true;
  }

  return false;
};
/**
 * Returns the SimpleSchema of the type of the given definition
 */

const getFirstSchemaFromDefinition = definition => {
  const type = definition.type; // Check whether we need to handle multiple definitions & non SimpleSchemaGroups

  if (type && type.definitions && type.definitions[0]) {
    return type.definitions[0].type;
  }

  throw new Error('No schema found');
};
/**
 *  Returns true if the given SimpleSchema definition contains an array
 */

const isDefinitionTypeArray = definition => {
  const type = definition.type; // Check whether we need to handle multiple definitions

  if (type && type.definitions[0] && type.definitions[0].type === Array) {
    return true;
  }

  return false;
};
const forEachKeyInSchemas = function (schema, callback) {
  let prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
  let rootPathPrefix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
  const nodeNames = schema.objectKeys(prefix);
  let valuePrefix = '';

  if (prefix.length > 0) {
    valuePrefix = `${prefix}.`;
  }

  let rootPrefix = '';

  if (rootPathPrefix.length > 0) {
    rootPrefix = `${rootPathPrefix}.`;
  }

  nodeNames.forEach(name => {
    const definitionPath = `${valuePrefix}${name}`;
    const pathFromRoot = `${rootPrefix}${name}`;
    const origDefinition = schema.schema(definitionPath);
    let hasChildren = false;

    if (!origDefinition || !origDefinition.accessibility || !origDefinition.accessibility.inseparable) {
      if (isDefinitionTypeSchema(origDefinition)) {
        const subSchema = getFirstSchemaFromDefinition(origDefinition);
        hasChildren = forEachKeyInSchemas(subSchema, callback, '', pathFromRoot);
      } else if (isDefinitionTypeArray(origDefinition)) {
        const arrayPath = definitionPath + '.$';
        const rootArrayPath = pathFromRoot + '.$';
        const arrayFieldDefinition = schema.schema(arrayPath);

        if (isDefinitionTypeSchema(arrayFieldDefinition)) {
          const subSchema = getFirstSchemaFromDefinition(arrayFieldDefinition);
          hasChildren = forEachKeyInSchemas(subSchema, callback, '', rootArrayPath);
        } else {
          hasChildren = forEachKeyInSchemas(schema, callback, arrayPath, rootArrayPath);
        }
      } else {
        hasChildren = forEachKeyInSchemas(schema, callback, definitionPath, pathFromRoot);
      }
    }

    callback(schema, definitionPath, pathFromRoot, hasChildren);
  });
  return nodeNames.length > 0;
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
    return;
  }

  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function isOrRule(rule) {
  return rule.hasOwnProperty('$or');
}

function isAndRule(rule) {
  return rule.hasOwnProperty('$and');
}

function isMatchRule(rule) {
  return !isAndRule(rule) && !isOrRule(rule);
}
// this does not align with Kleene and Priest logics, but knowing that a rule does not apply
// is strong enough reason to determine that the or should be false


function evaluateOrRule(data, orRule) {
  let finalResult = 'unknown';

  for (const rule of orRule.$or) {
    const result = evaluateRule(data, rule);

    if (result === 'true') {
      return 'true';
    } // apply not found if nothing was found before


    if (finalResult === 'unknown') {
      finalResult = result;
    }
  }

  return finalResult;
}

function evaluateAndRule(data, andRule) {
  for (const rule of andRule.$and) {
    const result = evaluateRule(data, rule);

    if (result !== 'true') {
      return 'false';
    }
  }

  return 'true';
} // read the value out of a quantity


function getQuantityValue(a) {
  let aValue = 0;

  if (typeof a === 'object') {
    // todo use better conversion in the future
    const multiplier = a.unit === 'inch' ? 2.54 : 1;
    aValue = a.value * multiplier;
  } else {
    aValue = a;
  }

  return aValue;
}

const allowedOperators = Object.freeze(['$eq', '$lt', '$lte', '$gt', '$gte', '$ne']); // compare two values using an operator, if they are quantities, read the underlying value

function compareByOperator(first, second) {
  let operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '$eq';
  const a = getQuantityValue(first);
  const b = getQuantityValue(second);

  if (operator === '$eq') {
    return a === b;
  }

  if (operator === '$lt') {
    return a < b;
  }

  if (operator === '$lte') {
    return a <= b;
  }

  if (operator === '$gt') {
    return a > b;
  }

  if (operator === '$gte') {
    return a >= b;
  }

  if (operator === '$ne') {
    return a !== b;
  }

  return false;
} // checks wether the given data matches the rule


function evaluateMatchRule(data, rule) {
  let finalResult = undefined;

  for (const _ref of entries(rule)) {
    var _ref2 = slicedToArray(_ref, 2);

    const path = _ref2[0];
    const matcher = _ref2[1];
    const fieldData = get(data, path);
    const isObjectMatch = typeof matcher === 'object';
    const isUnknownOrRule = matcher && isObjectMatch && matcher.hasOwnProperty('$unknownOr');
    const isExistsRule = matcher && isObjectMatch && matcher.hasOwnProperty('$exists');
    const isDefinedRule = matcher && isObjectMatch && matcher.hasOwnProperty('$defined');

    if (typeof fieldData === 'undefined' && !isDefinedRule && !isUnknownOrRule) {
      return 'unknown';
    }

    if (matcher && isObjectMatch) {
      let matched = false;
      const foundOperators = intersection(allowedOperators, Object.keys(matcher || {}));

      if (foundOperators.length === 1) {
        // compare by operator
        matched = compareByOperator(fieldData, matcher[foundOperators[0]], foundOperators[0]);
      } else if (isDefinedRule) {
        // custom defined check, unknown check is skipped above
        matched = typeof fieldData !== 'undefined';
      } else if (isExistsRule) {
        // custom exists check
        const existsValue = matcher['$exists'];
        matched = fieldData !== null === existsValue;
      } else if (isUnknownOrRule) {
        // either undefined or exactly the value
        const unknownOrValue = matcher['$unknownOr'];
        matched = fieldData === unknownOrValue || typeof fieldData === 'undefined';
      } else {
        // match whole object
        matched = isMatch(fieldData, matcher);
      } // abort early with no match


      if (!matched) {
        // any failed comparision and we fail the whole match
        return 'false';
      }

      if (typeof finalResult === 'undefined') {
        // mark result as yes, and continue checking
        finalResult = 'true';
      }
    } else {
      // normal data, do a deep equals
      const equals = isEqual(fieldData, matcher);

      if (!equals) {
        // any failed comparision and we fail the whole match
        return 'false';
      }

      if (typeof finalResult === 'undefined') {
        // mark result as yes, and continue checking
        finalResult = 'true';
      }
    }
  }
  return finalResult || 'unknown';
} // evaluates any kind of rule


function evaluateRule(data, rule) {
  let result = 'unknown';

  if (isOrRule(rule)) {
    result = evaluateOrRule(data, rule);
  } else if (isAndRule(rule)) {
    result = evaluateAndRule(data, rule);
  } else if (isMatchRule(rule)) {
    result = evaluateMatchRule(data, rule);
  }
  return result;
}

const flatStepHeight = {
  unit: 'cm',
  value: 7,
  operator: '<='
}; // TODO put real values in here!

const wheelChairWashBasin = {
  height: {
    unit: 'cm',
    operator: '>=',
    value: 80
  },
  depth: {
    unit: 'cm',
    operator: '>=',
    value: 50
  }
}; // the rules for determining that places are fully accessible
// first version only support one entrance / stair

const fullWheelmapA11yRuleSet = {
  $or: [{
    'properties.accessibility.entrances.0.hasFixedRamp': true
  }, {
    'properties.accessibility.entrances.0.hasRemovableRamp': true
  }, {
    'properties.accessibility.entrances.0.stairs.0.count': 0
  }, {
    'properties.accessibility.entrances.0.stairs': null
  }, {
    'properties.accessibility.entrances.0.isLevel': true
  }] // TODO add more rules for door width etc., multiple entrances, etc.

}; // the rules for determining that places are at least partially accessible, omitting the full rules
// first version only support one entrance / stair

const partialWheelmapA11yRuleSet = {
  $or: [{
    'properties.accessibility.entrances.0.stairs.0.count': 1,
    'properties.accessibility.entrances.0.stairs.0.stepHeight': {
      $lte: {
        value: 7.0,
        unit: 'cm'
      }
    }
  }] // TODO add more rules for door width etc., multiple entrances, etc.

}; // the rules for determining that toilets are fully accessible
// first version only support one restroom

const wheelmapToiletA11yRuleSet = {
  'properties.accessibility.restrooms': {
    $exists: true
  },
  'properties.accessibility.restrooms.0': {
    $exists: true
  },
  'properties.accessibility.restrooms.0.toilet': {
    $exists: true
  },
  'properties.accessibility.restrooms.0.entrance.isLevel': true,
  'properties.accessibility.restrooms.0.washBasin.accessibleWithWheelchair': true // TODO add more rules for door width etc.

}; // Evaluates the wheelchair accessibility using the predefined wheelmap rulesets

function evaluateWheelmapA11y(data) {
  const full = evaluateRule(data, fullWheelmapA11yRuleSet);

  if (full === 'true') {
    return 'yes';
  }

  const partial = evaluateRule(data, partialWheelmapA11yRuleSet);

  if (partial === 'true') {
    return 'partial';
  }

  if (full === 'false' || partial === 'false') {
    return 'no';
  }

  return 'unknown';
} // Evaluates the wheelchair accessibility of the toilet using the predefined wheelmap rulesets

function evaluateToiletWheelmapA11y(data) {
  const full = evaluateRule(data, wheelmapToiletA11yRuleSet);

  if (full === 'true') {
    return 'yes';
  }

  if (full === 'false') {
    return 'no';
  }

  return 'unknown';
}

const parseValue = (data, field, type) => {
  const rawValue = data[field];

  if (rawValue === null || typeof rawValue === 'undefined') {
    return rawValue;
  }

  if (typeof rawValue !== 'string') {
    return undefined;
  }

  if (type === 'yesno') {
    if (rawValue === 'true') {
      return true;
    }

    return rawValue === 'false' ? false : undefined;
  }

  if (type === 'float') {
    return parseFloat(rawValue);
  }

  if (type === 'int') {
    return parseInt(rawValue, 10);
  }

  return undefined;
};

const parseYesNo = (data, field) => {
  return parseValue(data, field, 'yesno');
};

const parseHasWithDefault = (data, field, existsValue, doesNotExistValue) => {
  const value = parseValue(data, field, 'yesno');

  if (value === true) {
    return existsValue;
  }

  if (value === false) {
    return doesNotExistValue;
  }

  return undefined;
};

const parseHasArray = (data, field) => {
  return parseHasWithDefault(data, field, [], null);
};

const parseHasEntry = (data, field) => {
  return parseHasWithDefault(data, field, {}, null);
};

const parseIsAnyOfWithDefault = (data, field, list, existsValue, doesNotExistValue) => {
  const rawValue = data[field];

  if (rawValue === null || typeof rawValue === 'undefined') {
    return rawValue;
  }

  return includes(list, rawValue) ? existsValue : doesNotExistValue;
};

const parseIsAnyOf = (data, field, list) => {
  return parseIsAnyOfWithDefault(data, field, list, true, false);
};

const parseIsAnyOfEntry = (data, field, list) => {
  return parseIsAnyOfWithDefault(data, field, list, {}, undefined);
};

const parseFloatUnit = (data, field, unit, operator) => {
  const value = parseValue(data, field, 'float'); // remove undefined values

  const unitValue = pickBy({
    operator,
    unit,
    value
  });
  return value && !isNaN(value) ? unitValue : undefined;
};

const parseMultiSelect = (data, field) => {
  const rawValue = data[field];

  if (rawValue === null || typeof rawValue === 'undefined') {
    return rawValue;
  }

  if (typeof rawValue !== 'string') {
    return undefined;
  }

  return rawValue.split(' ');
};

const transformKoboToA11y = data => {
  const usedLengthUnit = data['user/user_measuring'] || 'cm';
  const mapping = {
    geometry: data._geolocation ? {
      coordinates: data._geolocation.reverse(),
      type: 'Point'
    } : {},
    'properties.originalId': data._id && `${data._id}`,
    'properties.infoPageUrl': null,
    'properties.originalData': JSON.stringify(data),
    // basic place data
    'properties.name': data['outside/name'],
    'properties.phoneNumber': data['place_phone_number'] || data['phone_number'],
    'properties.emailAddress': data['place_email_address'],
    'properties.placeWebsiteUrl': data['place_website_url'],
    'properties.category': data['outside/category/category_top'] || data['outside/category/category_sub'] || 'undefined',
    'properties.description': data['wheelchair_comment'],
    'properties.accessibility.accessibleWith.wheelchair': {
      true: true,
      false: false,
      partially: false
    }[data['is_wheelchair_accessible']],
    'properties.accessibility.partiallyAccessibleWith.wheelchair': data['is_wheelchair_accessible'] === 'partially' ? true : undefined,
    // entrances
    'properties.accessibility.isWellLit': parseYesNo(data, 'inside/is_well_lit'),
    'properties.accessibility.isQuiet': parseYesNo(data, 'inside/is_quiet'),
    'properties.accessibility.entrances': parseHasArray(data, 'outside/entrance/has_entrance'),
    'properties.accessibility.entrances.0': parseHasEntry(data, 'outside/entrance/has_entrance'),
    'properties.accessibility.entrances.0.hasFixedRamp': parseYesNo(data, 'outside/entrance/has_fixed_ramp'),
    // stairs
    'properties.accessibility.entrances.0.stairs': parseHasArray(data, 'outside/entrance/has_steps'),
    'properties.accessibility.entrances.0.stairs.0': parseHasEntry(data, 'outside/entrance/has_steps'),
    'properties.accessibility.entrances.0.stairs.0.count': parseValue(data, 'outside/entrance/steps_count', 'int'),
    'properties.accessibility.entrances.0.stairs.0.stepHeight': parseFloatUnit(data, 'outside/entrance/steps_height', usedLengthUnit) || parseHasWithDefault(data, 'outside/entrance/steps_low_height', flatStepHeight, undefined),
    'properties.accessibility.entrances.0.hasRemovableRamp': parseYesNo(data, 'outside/entrance/has_mobile_ramp'),
    // doors
    'properties.accessibility.entrances.0.doors': parseHasArray(data, 'outside/entrance/has_door'),
    'properties.accessibility.entrances.0.doors.0': parseHasEntry(data, 'outside/entrance/has_door'),
    'properties.accessibility.entrances.0.doors.0.isAutomaticOrAlwaysOpen': parseYesNo(data, 'outside/entrance/has_automatic_door'),
    // restrooms
    'properties.accessibility.restrooms': parseHasArray(data, 'inside/toilet/has_toilet'),
    'properties.accessibility.restrooms.0': parseHasEntry(data, 'inside/toilet/has_toilet'),
    // entrance
    'properties.accessibility.restrooms.0.entrance.isLevel': parseYesNo(data, 'inside/toilet/stepless_access'),
    'properties.accessibility.restrooms.0.entrance.door.width': parseFloatUnit(data, 'inside/toilet/door_width', usedLengthUnit),
    // toilet
    'properties.accessibility.restrooms.0.toilet': parseHasEntry(data, 'inside/toilet/has_toilet'),
    'properties.accessibility.restrooms.0.toilet.heightOfBase': parseFloatUnit(data, 'inside/toilet/seat_height', usedLengthUnit),
    'properties.accessibility.restrooms.0.toilet.spaceOnUsersLeftSide': parseFloatUnit(data, 'inside/toilet/free_space_left', usedLengthUnit),
    'properties.accessibility.restrooms.0.toilet.spaceOnUsersRightSide': parseFloatUnit(data, 'inside/toilet/free_space_right', usedLengthUnit),
    'properties.accessibility.restrooms.0.toilet.spaceInFront': parseFloatUnit(data, 'inside/toilet/free_space_front', usedLengthUnit),
    // bars
    'properties.accessibility.restrooms.0.toilet.hasGrabBars': parseIsAnyOf(data, 'inside/toilet/has_arm_rests', ['left_and_right', 'right', 'left']),
    'properties.accessibility.restrooms.0.toilet.grabBars': parseIsAnyOfEntry(data, 'inside/toilet/has_arm_rests', ['left_and_right', 'right', 'left']),
    'properties.accessibility.restrooms.0.toilet.grabBars.onUsersLeftSide': parseIsAnyOf(data, 'inside/toilet/has_arm_rests', ['left_and_right', 'left']),
    'properties.accessibility.restrooms.0.toilet.grabBars.onUsersRightSide': parseIsAnyOf(data, 'inside/toilet/has_arm_rests', ['left_and_right', 'right']),
    // washBasin
    'properties.accessibility.restrooms.0.washBasin': parseHasEntry(data, 'inside/toilet/has_basin'),
    'properties.accessibility.restrooms.0.washBasin.accessibleWithWheelchair': parseYesNo(data, 'inside/toilet/basin_wheelchair_reachable'),
    'properties.accessibility.restrooms.0.washBasin.spaceBelow': parseHasWithDefault(data, 'inside/toilet/basin_wheelchair_fits_belows', wheelChairWashBasin, null),
    'properties.accessibility.restrooms.0.washBasin.isLocatedInsideRestroom': parseYesNo(data, 'inside/toilet/basin_inside_cabin'),
    // animal policy
    'properties.accessibility.animalPolicy.allowsServiceAnimals': parseYesNo(data, 'inquire/are_service_animals_allowed'),
    // staff
    'properties.accessibility.staff.isTrainedForDisabilities': parseYesNo(data, 'inquire/staff_has_disabled_training'),
    'properties.accessibility.staff.spokenLanguages': parseMultiSelect(data, 'inquire/staff_spoken_sign_langs'),
    'properties.accessibility.staff.isTrainedInSigning': parseYesNo(data, 'inquire/staff_can_speak_sign_lang'),
    // media
    'properties.accessibility.media.isLargePrint': parseYesNo(data, 'inquire/media/has_large_print'),
    'properties.accessibility.media.isAudio': parseYesNo(data, 'inquire/media/has_audio'),
    'properties.accessibility.media.isBraille': parseYesNo(data, 'inquire/media/has_braille')
  };
  const result = {
    properties: {
      hasAccessibility: true
    }
  }; // if there is a null in the history, do not set a value

  const customizedSetter = currValue => currValue === null ? null : undefined;

  for (const _ref of entries(mapping)) {
    var _ref2 = slicedToArray(_ref, 2);

    const key = _ref2[0];
    const value = _ref2[1];

    if (typeof value !== 'undefined') {
      setWith(result, key, value, customizedSetter);
    }
  }

  const userDefinedA11y = data['is_wheelchair_accessible'];

  if (!userDefinedA11y || userDefinedA11y === 'undefined') {
    // rate place a11y automatically
    const a11y = evaluateWheelmapA11y(result); // Currently, these fields are exlusive.

    if (a11y === 'yes') {
      set(result, 'properties.accessibility.accessibleWith.wheelchair', true);
      unset(result, 'properties.accessibility.partiallyAccessibleWith.wheelchair');
    } else if (a11y === 'partial') {
      unset(result, 'properties.accessibility.accessibleWith.wheelchair');
      set(result, 'properties.accessibility.partiallyAccessibleWith.wheelchair', true);
    } else if (a11y === 'no') {
      set(result, 'properties.accessibility.accessibleWith.wheelchair', false);
      unset(result, 'properties.accessibility.partiallyAccessibleWith.wheelchair');
    }
  } else {
    // ensure that only one value is set to true
    if (get(result, 'properties.accessibility.accessibleWith.wheelchair') === true) {
      unset(result, 'properties.accessibility.partiallyAccessibleWith.wheelchair');
    } else if (get(result, 'properties.accessibility.partiallyAccessibleWith.wheelchair') === true) {
      unset(result, 'properties.accessibility.accessibleWith.wheelchair');
    }
  }

  if (Object.keys(get(result, 'properties.accessibility.accessibleWith') || {}).length === 0) {
    unset(result, 'properties.accessibility.accessibleWith');
  }

  if (Object.keys(get(result, 'properties.accessibility.partiallyAccessibleWith') || {}).length === 0) {
    unset(result, 'properties.accessibility.partiallyAccessibleWith');
  } // rate place a11y


  const toiletA11y = evaluateToiletWheelmapA11y(result); // rate toilet a11y
  // TODO this field doesn't exist in ac format! Clarify & align with wheelmap frontend & a11yjson

  if (toiletA11y === 'yes') {
    setWith(result, 'properties.accessibility.restrooms.0.isAccessibleWithWheelchair', true, customizedSetter);
  } else if (toiletA11y === 'no') {
    setWith(result, 'properties.accessibility.restrooms.0.isAccessibleWithWheelchair', false, customizedSetter);
  }

  return result;
};

export { AccessibilitySchema, AccessibilitySchemaExtensionSchema, AccessibleTablesPrefab, AddressSchema, AllowedEquipmentTypes, AnimalPolicySchema, BaseQuantitySchema, DoorSchema, EntranceSchema, EquipmentInfoSchema, EquipmentPropertiesSchema, ExternalIdSchema, FormatVersion, GeometrySchema, GrabBarsSchema, GroundSchema, LengthQuantitySchema, LengthSchema, LengthUnitKind, LocalizedStringSchema, MediaSchema, MirrorSchema, OtherUnitKind, ParkingSchema, PathwaysSchema, PaymentSchema, PersonalProfileSchema, PlaceInfoSchema, PlacePropertiesSchema, PointGeometrySchema, QuestionFunctionContext, RestroomSchema, RoomSchema, ShowerSchema, StaffSchema, StairsSchema, StructuredAddressSchema, TablesSchema, ToiletSchema, VolumeQuantitySchema, VolumeSchema, WashBasinSchema, WheelchairParkingSchema, WheelchairPlacesSchema, createSchemaInstance, determineUnitKind, evaluateAccessibilitySchemaExtension, evaluateQuestionValue, evaluateRule, evaluateToiletWheelmapA11y, evaluateWheelmapA11y, flatStepHeight, forEachKeyInSchemas, fullWheelmapA11yRuleSet, getFirstSchemaFromDefinition, ietfLanguageTags, ietfLanguageTagsAndSignLanguageCodes, isDefinitionTypeArray, isDefinitionTypeSchema, isoAlphaThreeCountryCodes, makeQuestionContext, partialWheelmapA11yRuleSet, quantityDefinition, signLanguageCodes, smokingPolicies, transformKoboToA11y, validateUnit, wheelChairWashBasin, wheelmapToiletA11yRuleSet };
