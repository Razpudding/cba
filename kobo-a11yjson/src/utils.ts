//TODO: Had to type object as any because otherwise 'object[key]' throws an error
//	should prob be fixed in a typed way
export function cleanKeys(object:any){
	const keyValues = Object.keys(object).map(key => {
		//Remove all numerical suffixes generated by Kobo
		const newKey = key.replace(/_0../g, '')
		return { [newKey]: object[key] }
	})
	return Object.assign({}, ...keyValues)
}

export function cleanKeysOneLevel(object:any){
	const keyValues = Object.keys(object).map(key => {
		//Remove all numerical suffixes generated by Kobo
		const newKey = key.replace(/_.../, '')
		return { [newKey]: object[key] }
	})
	return Object.assign({}, ...keyValues)
}

export function formIsolatedObject(object:any, nesting:string){
	const isolatedObject:any = {}
	for (const [key, value] of Object.entries(object)) {
	  if (key.startsWith(nesting)){
	  	isolatedObject[key.split(nesting)[1]] = value
	  }
	}
	return isolatedObject
}

//Cleans numerical suffixes from keys containing a target string
export function cleanKeysStartingWith(object:any, target:string){
	const keyValues = Object.keys(object).map(key => {
		let newKey:string = key
		if(key.includes(target)){
			// Remove all numerical suffixes generated by Kobo
			//	Split the current key using the target (e.g. Entrance_001)
			//	Return the first part unaltered, the target unaltered
			//	and remove all numerical suffixed from the second part
			newKey = key.split(target)[0] + target +key.split(target)[1].replace(/_.../g, '')
		}
		// Return an object with the new key and original value
		return { [newKey]: object[key] }
	})
	// Spread the new keys with their values into a fresh object and return it
	return Object.assign({}, ...keyValues)
}

//If a value is an empty string, change it to undefined
export function cleanValues(object:any){
	for (const val in object){
		object[val] = object[val] === '' ? undefined : object[val]
	}
	return object
}